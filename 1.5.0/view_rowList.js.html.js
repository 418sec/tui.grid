tui.util.defineNamespace("fedoc.content", {});
fedoc.content["view_rowList.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview RowList View\n * @author NHN Ent. FE Development Team\n */\n'use strict';\n\nvar _ = require('underscore');\n\nvar View = require('../base/view');\nvar util = require('../common/util');\nvar attrNameConst = require('../common/constMap').attrName;\nvar classNameConst = require('../common/classNameConst');\n\n/**\n * RowList View\n * @module view/rowList\n * @extends module:baes/view\n */\nvar RowList = View.extend(/**@lends module:view/rowList.prototype */{\n    /**\n     * @constructs\n     * @param {object} options - Options\n     * @param {string} [options.whichSide='R']   어느 영역에 속하는 rowList 인지 여부. 'L|R' 중 하나를 지정한다.\n     */\n    initialize: function(options) {\n        var focusModel = options.focusModel,\n            renderModel = options.renderModel,\n            selectionModel = options.selectionModel,\n            whichSide = options.whichSide || 'R';\n\n        this.setOwnProperties({\n            whichSide: whichSide,\n            bodyTableView: options.bodyTableView,\n            focusModel: focusModel,\n            renderModel: renderModel,\n            selectionModel: selectionModel,\n            dataModel: options.dataModel,\n            columnModel: options.columnModel,\n            collection: renderModel.getCollection(whichSide),\n            painterManager: options.painterManager,\n            sortOptions: null,\n            renderedRowKeys: null\n        });\n\n        this.listenTo(this.collection, 'change', this._onModelChange)\n            .listenTo(this.collection, 'restore', this._onModelRestore)\n            .listenTo(focusModel, 'change:rowKey', this._refreshFocusedRow)\n            .listenTo(renderModel, 'rowListChanged', this.render);\n\n        if (this.whichSide === 'L') {\n            this.listenTo(focusModel, 'change:rowKey', this._refreshSelectedMetaColumns)\n                .listenTo(selectionModel, 'change:range', this._refreshSelectedMetaColumns)\n                .listenTo(renderModel, 'rowListChanged', this._refreshSelectedMetaColumns);\n        }\n    },\n\n    /**\n     * Returns the list of column models in it's own side\n     * @returns {Array} - Column model list\n     */\n    _getColumnModelList: function() {\n        return this.columnModel.getVisibleColumnModelList(this.whichSide, true);\n    },\n\n    /**\n     * 기존에 생성되어 있던 TR요소들 중 새로 렌더링할 데이터와 중복되지 않은 목록의 TR요소만 삭제한다.\n     * @param {array} dupRowKeys 중복된 데이터의 rowKey 목록\n     */\n    _removeOldRows: function(dupRowKeys) {\n        var firstIdx = _.indexOf(this.renderedRowKeys, dupRowKeys[0]),\n            lastIdx = _.indexOf(this.renderedRowKeys, _.last(dupRowKeys)),\n            $rows = this.$el.children('tr');\n\n        $rows.slice(0, firstIdx).remove();\n        $rows.slice(lastIdx + 1).remove();\n    },\n\n    /**\n     * 기존의 렌더링된 데이터와 중복되지 않은 목록에 대해서만 TR요소를 추가한다.\n     * @param {array} rowKeys 렌더링할 데이터의 rowKey 목록\n     * @param {array} dupRowKeys 중복된 데이터의 rowKey 목록\n     */\n    _appendNewRows: function(rowKeys, dupRowKeys) {\n        var beforeRows = this.collection.slice(0, _.indexOf(rowKeys, dupRowKeys[0])),\n            afterRows = this.collection.slice(_.indexOf(rowKeys, _.last(dupRowKeys)) + 1);\n\n        this.$el.prepend(this._getRowsHtml(beforeRows));\n        this.$el.append(this._getRowsHtml(afterRows));\n    },\n\n    /**\n     * Redraw all rows.\n     * @private\n     */\n    _resetRows: function() {\n        var html = this._getRowsHtml(this.collection.models),\n            $tbody;\n\n        if (RowList.isInnerHtmlOfTbodyReadOnly) {\n            $tbody = this.bodyTableView.redrawTable(html);\n            this.setElement($tbody, false); // table이 다시 생성되었기 때문에 tbody의 참조를 갱신해준다.\n\n            // prevent layout from breaking in IE7\n            if (util.isBrowserIE7()) {\n                $tbody.width($tbody.width());\n            }\n        } else {\n            // As using a compatibility mode in IE makes it hard to detect the actual version of the browser,\n            // use try/catch block to make in correct.\n            try {\n                this.$el[0].innerHTML = html;\n            } catch (e) {\n                RowList.isInnerHtmlOfTbodyReadOnly = true;\n                this._resetRows();\n            }\n        }\n    },\n\n    /**\n     * 행데이터 목록을 받아, HTML 문자열을 생성해서 반환한다.\n     * @param {Model.Row[]} rows - 행데이터 목록\n     * @returns {string} 생성된 HTML 문자열\n     */\n    _getRowsHtml: function(rows) {\n        var rowPainter = this.painterManager.getRowPainter(),\n            columnNames = _.pluck(this._getColumnModelList(), 'columnName');\n\n        return _.map(rows, function(row) {\n            return rowPainter.generateHtml(row, columnNames);\n        }).join('');\n    },\n\n    /**\n     * Returns a TR element of given rowKey\n     * @param {(string|number)} rowKey - rowKey\n     * @returns {jquery}\n     * @private\n     */\n    _getRowElement: function(rowKey) {\n        return this.$el.find('tr[' + attrNameConst.ROW_KEY + '=' + rowKey + ']');\n    },\n\n    /**\n     * Refreshes 'selected' class of meta columns.\n     * @private\n     */\n    _refreshSelectedMetaColumns: function() {\n        var $rows = this.$el.find('tr');\n        var metaSelector = '.' + classNameConst.CELL_HEAD;\n        var $filteredRows;\n\n        if (this.selectionModel.hasSelection()) {\n            $filteredRows = this._filterRowsByIndexRange($rows, this.selectionModel.get('range').row);\n        } else {\n            $filteredRows = this._filterRowByKey($rows, this.focusModel.get('rowKey'));\n        }\n\n        $rows.find(metaSelector).removeClass(classNameConst.CELL_SELECTED);\n        $filteredRows.find(metaSelector).addClass(classNameConst.CELL_SELECTED);\n    },\n\n    /**\n     * Filters the rows by given range(index) and returns them.\n     * @param {jQuery} $rows - rows (tr elements)\n     * @param {Array.&lt;Number>} rowRange - [startIndex, endIndex]\n     * @returns {jQuery}\n     * @private\n     */\n    _filterRowsByIndexRange: function($rows, rowRange) {\n        var renderModel = this.renderModel,\n            renderStartIndex = renderModel.get('startIndex'),\n            startIndex, endIndex;\n\n        startIndex = Math.max(rowRange[0] - renderStartIndex, 0);\n        endIndex = Math.max(rowRange[1] - renderStartIndex + 1, 0); // add 1 for exclusive value\n\n        if (!startIndex &amp;&amp; !endIndex) {\n            return $();\n        }\n        return $rows.slice(startIndex, endIndex);\n    },\n\n    /**\n     * Filters the row by given rowKey\n     * @param {jQuery} $rows - rows (tr elements)\n     * @param {Number} rowKey - rowKey\n     * @returns {jQuery}\n     * @private\n     */\n    _filterRowByKey: function($rows, rowKey) {\n        var rowIndex = this.dataModel.indexOfRowKey(rowKey),\n            renderStartIndex = this.renderModel.get('startIndex');\n\n        if (renderStartIndex > rowIndex) {\n            return $();\n        }\n        return $rows.eq(rowIndex - renderStartIndex);\n    },\n\n    /**\n     * Removes the CURRENT_ROW class from the cells in the previously focused row and\n     * adds it to the cells in the currently focused row.\n     * @private\n     */\n    _refreshFocusedRow: function() {\n        var rowKey = this.focusModel.get('rowKey');\n        var prevRowKey = this.focusModel.get('prevRowKey');\n\n        this._setFocusedRowClass(prevRowKey, false);\n        this._setFocusedRowClass(rowKey, true);\n    },\n\n    /**\n     * Finds all cells in the row indentified by given rowKey and toggles the CURRENT_ROW on them.\n     * @param {Number|String} rowKey - rowKey\n     * @param {Boolean} focused - if set to true, the class will be added, otherwise be removed.\n     * @private\n     */\n    _setFocusedRowClass: function(rowKey, focused) {\n        var columnNames = _.pluck(this._getColumnModelList(), 'columnName'),\n            trMap = {};\n\n        _.each(columnNames, function(columnName) {\n            var mainRowKey = this.dataModel.getMainRowKey(rowKey, columnName),\n                $td;\n\n            if (!trMap[mainRowKey]) {\n                trMap[mainRowKey] = this._getRowElement(mainRowKey);\n            }\n            $td = trMap[mainRowKey].find('td[' + attrNameConst.COLUMN_NAME + '=\"' + columnName + '\"]');\n            $td.toggleClass(classNameConst.CELL_CURRENT_ROW, focused);\n        }, this);\n    },\n\n    /**\n     * Renders.\n     * @param {boolean} dataModelChanged - 모델이 변경된 경우(add, remove..) true, 아니면(스크롤 변경 등) false\n     * @returns {View.RowList} this 객체\n     */\n    render: function(dataModelChanged) {\n        var rowKeys = this.collection.pluck('rowKey'),\n            dupRowKeys;\n\n        this.bodyTableView.resetTablePosition();\n\n        if (dataModelChanged) {\n            this._resetRows();\n        } else {\n            dupRowKeys = _.intersection(rowKeys, this.renderedRowKeys);\n            if (_.isEmpty(rowKeys) || _.isEmpty(dupRowKeys) ||\n                // 중복된 데이터가 70% 미만일 경우에는 성능을 위해 innerHTML을 사용.\n                (dupRowKeys.length / rowKeys.length &lt; 0.7)) { // eslint-disable-line no-magic-numbers\n                this._resetRows();\n            } else {\n                this._removeOldRows(dupRowKeys);\n                this._appendNewRows(rowKeys, dupRowKeys);\n            }\n        }\n        this.renderedRowKeys = rowKeys;\n\n        return this;\n    },\n\n    /**\n     * modelChange 이벤트 발생시 실행되는 핸들러 함수.\n     * @param {Model.Row} model Row 모델 객체\n     * @private\n     */\n    _onModelChange: function(model) {\n        var $tr = this._getRowElement(model.get('rowKey'));\n\n        this.painterManager.getRowPainter().refresh(model.changed, $tr);\n    },\n\n    /**\n     * Event handler for 'restore' event on module:model/row\n     * @param {Object} cellData - CellData\n     * @private\n     */\n    _onModelRestore: function(cellData) {\n        var $td = this.dataModel.getElement(cellData.rowKey, cellData.columnName);\n        var editType = this.columnModel.getEditType(cellData.columnName);\n\n        this.painterManager.getCellPainter(editType).refresh(cellData, $td);\n    }\n}, {\n    /**\n     * Whether the innerHTML property of a tbody element is readonly.\n     * @memberof RowList\n     * @static\n     */\n    isInnerHtmlOfTbodyReadOnly: (tui.util.browser.msie &amp;&amp;\n        tui.util.browser.version &lt;= 9) // eslint-disable-line no-magic-numbers\n});\n\nmodule.exports = RowList;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"