tui.util.defineNamespace("fedoc.content", {});
fedoc.content["model_focus.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Focus 관련 데이터 처리름 담당한다.\n * @author NHN Ent. FE Development Team\n */\n'use strict';\n\nvar _ = require('underscore');\n\nvar Model = require('../base/model');\nvar util = require('../common/util');\nvar GridEvent = require('../common/gridEvent');\n\n/**\n * Focus model\n * RowList collection 이 focus class 를 listen 한다.\n * @module model/focus\n * @extends module:base/model\n */\nvar Focus = Model.extend(/**@lends module:model/focus.prototype */{\n    /**\n     * @constructs\n     * @param {Object} attrs - Attributes\n     * @param {Object} options - Options\n     */\n    initialize: function(attrs, options) {\n        Model.prototype.initialize.apply(this, arguments);\n\n        this.dataModel = options.dataModel;\n        this.columnModel = options.columnModel;\n        this.dimensionModel = options.dimensionModel;\n        this.domState = options.domState;\n\n        this.listenTo(this.dataModel, 'reset', this._onResetData);\n    },\n\n    defaults: {\n        /**\n         * row key of the current cell\n         * @type {String|Number}\n         */\n        rowKey: null,\n\n        /**\n         * column name of the current cell\n         * @type {String}\n         */\n        columnName: '',\n\n        /**\n         * row key of the previously focused cell\n         * @type {String|Number}\n         */\n        prevRowKey: null,\n\n        /**\n         * column name of the previously focused cell\n         * @type {String}\n         */\n        prevColumnName: '',\n\n        /**\n         * address of the editing cell.\n         * @type {{rowKey:(String|Number), columnName:String}}\n         */\n        editingAddress: null\n    },\n\n    /**\n     * Event handler for 'reset' event on dataModel.\n     * @private\n     */\n    _onResetData: function() {\n        this.unselect(true);\n    },\n\n    /**\n     * Saves previous data.\n     * @private\n     */\n    _savePrevious: function() {\n        if (this.get('rowKey') !== null) {\n            this.set('prevRowKey', this.get('rowKey'));\n        }\n        if (this.get('columnName')) {\n            this.set('prevColumnName', this.get('columnName'));\n        }\n    },\n\n    /**\n     * Clear previous data.\n     * @private\n     */\n    _clearPrevious: function() {\n        this.set({\n            prevRowKey: null,\n            prevColumnName: ''\n        });\n    },\n\n    /**\n     * Returns whether given rowKey and columnName is equal to current value\n     * @param {(Number|String)} rowKey - row key\n     * @param {String} columnName - column name\n     * @param {Boolean} isMainRowKey - true if the target row key is main row\n     * @returns {Boolean} - True if equal\n     */\n    isCurrentCell: function(rowKey, columnName, isMainRowKey) {\n        var curColumnName = this.get('columnName');\n        var curRowKey = this.get('rowKey');\n\n        if (isMainRowKey) {\n            curRowKey = this.dataModel.getMainRowKey(curRowKey, curColumnName);\n        }\n\n        return String(curRowKey) === String(rowKey) &amp;&amp; curColumnName === columnName;\n    },\n\n    /**\n     * Selects the given row\n     * @param {Number|String} rowKey - Rowkey of the target row\n     * @returns {Boolean} True is success\n     */\n    select: function(rowKey) {\n        var eventData = new GridEvent();\n        var currentRowKey = this.get('rowKey');\n\n        if (String(currentRowKey) === String(rowKey)) {\n            return true;\n        }\n\n        eventData.setData({\n            rowKey: rowKey,\n            prevRowKey: currentRowKey,\n            rowData: this.dataModel.getRowData(rowKey)\n        });\n        this.trigger('select', eventData);\n        if (eventData.isStopped()) {\n            this._cancelSelect();\n            return false;\n        }\n\n        this.set('rowKey', rowKey);\n        if (this.columnModel.get('selectType') === 'radio') {\n            this.dataModel.check(rowKey);\n        }\n        return true;\n    },\n\n    /**\n     * Cancel select\n     * @private\n     */\n    _cancelSelect: function() {\n        var prevColumnName = this.get('prevColumnName');\n\n        this.set('columnName', prevColumnName);\n        this.trigger('focus', this.get('rowKey'), prevColumnName);\n    },\n\n    /**\n     * 행을 unselect 한다.\n     * @param {boolean} blur - The boolean value whether to invoke blur\n     */\n    unselect: function(blur) {\n        if (blur) {\n            this.blur();\n        }\n        this.set({\n            rowKey: null\n        });\n    },\n\n    /**\n     * Focus to the cell identified by given rowKey and columnName.\n     * @param {Number|String} rowKey - rowKey\n     * @param {String} columnName - columnName\n     * @param {Boolean} isScrollable - if set to true, move scroll position to focused position\n     * @returns {Boolean} true if focused cell is changed\n     */\n    focus: function(rowKey, columnName, isScrollable) {\n        if (!this._isValidCell(rowKey, columnName) ||\n            util.isMetaColumn(columnName) ||\n            this.isCurrentCell(rowKey, columnName)) {\n            return true;\n        }\n\n        this.blur();\n        if (!this.select(rowKey)) {\n            return false;\n        }\n\n        this.set('columnName', columnName);\n        this.trigger('focus', rowKey, columnName);\n\n        if (isScrollable) {\n            this.scrollToFocus();\n        }\n        return true;\n    },\n\n    /**\n     * Focus to the cell identified by given rowIndex and columnIndex.\n     * @param {(Number|String)} rowIndex - rowIndex\n     * @param {String} columnIndex - columnIndex\n     * @param {boolean} [isScrollable=false] - if set to true, scroll to focused cell\n     * @returns {Boolean} true if success\n     */\n    focusAt: function(rowIndex, columnIndex, isScrollable) {\n        var row = this.dataModel.at(rowIndex);\n        var column = this.columnModel.at(columnIndex, true);\n        var result = false;\n\n        if (row &amp;&amp; column) {\n            result = this.focus(row.get('rowKey'), column.columnName, isScrollable);\n        }\n\n        return result;\n    },\n\n    /**\n     * Focus to the cell identified by given rowKey and columnName and change it to edit-mode if editable.\n     * @param {(Number|String)} rowKey - rowKey\n     * @param {String} columnName - columnName\n     * @param {boolean} [isScrollable=false] - if set to true, scroll to focused cell\n     * @returns {Boolean} true if success\n     */\n    focusIn: function(rowKey, columnName, isScrollable) {\n        var result = this.focus(rowKey, columnName, isScrollable);\n\n        if (result) {\n            rowKey = this.dataModel.getMainRowKey(rowKey, columnName);\n\n            if (this.dataModel.get(rowKey).isEditable(columnName)) {\n                this.finishEditing();\n                this.startEditing(rowKey, columnName);\n            } else {\n                this.focusClipboard();\n            }\n        }\n\n        return result;\n    },\n\n    /**\n     * Focus to the cell identified by given rowIndex and columnIndex and change it to edit-mode if editable.\n     * @param {(Number|String)} rowIndex - rowIndex\n     * @param {String} columnIndex - columnIndex\n     * @param {Boolean} [isScrollable=false] - if set to true, scroll to focused cell\n     * @returns {Boolean} true if success\n     */\n    focusInAt: function(rowIndex, columnIndex, isScrollable) {\n        var row = this.dataModel.at(rowIndex);\n        var column = this.columnModel.at(columnIndex, true);\n        var result = false;\n\n        if (row &amp;&amp; column) {\n            result = this.focusIn(row.get('rowKey'), column.columnName, isScrollable);\n        }\n        return result;\n    },\n\n    /**\n     * clipboard 에 focus 한다.\n     */\n    focusClipboard: function() {\n        this.trigger('focusClipboard');\n    },\n\n    /**\n     * If the grid has an element which has a focus, make sure that focusModel has a valid data,\n     * Otherwise call focusModel.blur().\n     */\n    refreshState: function() {\n        var restored;\n\n        if (!this.domState.hasFocusedElement()) {\n            this.blur();\n        } else if (!this.has()) {\n            restored = this.restore();\n            if (!restored) {\n                this.focusAt(0, 0);\n            }\n        }\n    },\n\n    /**\n     * Scroll to focus\n     */\n    scrollToFocus: function() {\n        var rowKey = this.get('rowKey');\n        var columnName = this.get('columnName');\n        var scrollPosition = this.dimensionModel.getScrollPosition(rowKey, columnName);\n\n        if (!tui.util.isEmpty(scrollPosition)) {\n            this.renderModel.set(scrollPosition);\n        }\n    },\n\n    /**\n     * 디자인 blur 처리한다.\n     * @returns {Model.Focus} This object\n     */\n    blur: function() {\n        var columnName = this.get('columnName');\n\n        if (!this.has()) {\n            return this;\n        }\n\n        if (this.has(true)) {\n            this._savePrevious();\n        }\n\n        if (this.get('rowKey') !== null) {\n            this.set('columnName', '');\n        }\n        this.trigger('blur', this.get('rowKey'), columnName);\n\n        return this;\n    },\n\n    /**\n     * 현재 focus 정보를 반환한다.\n     * @returns {{rowKey: (number|string), columnName: string}} 현재 focus 정보에 해당하는 rowKey, columnName\n     */\n    which: function() {\n        return {\n            rowKey: this.get('rowKey'),\n            columnName: this.get('columnName')\n        };\n    },\n\n    /**\n     * 현재 focus 정보를 index 기준으로 반환한다.\n     * @param {boolean} isPrevious 이전 focus 정보를 반환할지 여부\n     * @returns {{row: number, column: number}} The object that contains index info\n     */\n    indexOf: function(isPrevious) {\n        var rowKey = isPrevious ? this.get('prevRowKey') : this.get('rowKey');\n        var columnName = isPrevious ? this.get('prevColumnName') : this.get('columnName');\n\n        return {\n            row: this.dataModel.indexOfRowKey(rowKey),\n            column: this.columnModel.indexOfColumnName(columnName, true)\n        };\n    },\n\n    /**\n     * Returns whether has focus.\n     * @param {boolean} checkValid - if set to true, check whether the current cell is valid.\n     * @returns {boolean} True if has focus.\n     */\n    has: function(checkValid) {\n        var rowKey = this.get('rowKey');\n        var columnName = this.get('columnName');\n\n        if (checkValid) {\n            return this._isValidCell(rowKey, columnName);\n        }\n        return !util.isBlank(rowKey) &amp;&amp; !util.isBlank(columnName);\n    },\n\n    /**\n     * Restore previous focus data.\n     * @returns {boolean} True if restored\n     */\n    restore: function() {\n        var prevRowKey = this.get('prevRowKey');\n        var prevColumnName = this.get('prevColumnName');\n        var restored = false;\n\n        if (this._isValidCell(prevRowKey, prevColumnName)) {\n            this.focus(prevRowKey, prevColumnName);\n            restored = true;\n        }\n        return restored;\n    },\n\n    /**\n     * Returns whether the cell identified by given rowKey and columnName is editing now.\n     * @param {Number} rowKey - row key\n     * @param {String} columnName - column name\n     * @returns {Boolean}\n     */\n    isEditingCell: function(rowKey, columnName) {\n        var address = this.get('editingAddress');\n\n        return address &amp;&amp;\n            (String(address.rowKey) === String(rowKey)) &amp;&amp;\n            (address.columnName === columnName);\n    },\n\n    /**\n     * Starts editing a cell identified by given rowKey and columnName, and returns the result.\n     * @param {(String|Number)} rowKey - row key\n     * @param {String} columnName - column name\n     * @returns {Boolean} true if succeeded, false otherwise.\n     */\n    startEditing: function(rowKey, columnName) {\n        if (this.get('editingAddress')) {\n            return false;\n        }\n\n        if (_.isUndefined(rowKey) &amp;&amp; _.isUndefined(columnName)) {\n            rowKey = this.get('rowKey');\n            columnName = this.get('columnName');\n        } else if (!this.isCurrentCell(rowKey, columnName, true)) {\n            return false;\n        }\n\n        rowKey = this.dataModel.getMainRowKey(rowKey, columnName);\n        if (!this.dataModel.get(rowKey).isEditable(columnName)) {\n            return false;\n        }\n        this.set('editingAddress', {\n            rowKey: rowKey,\n            columnName: columnName\n        });\n\n        return true;\n    },\n\n    /**\n     * Finishes editing the current cell, and returns the result.\n     * @returns {Boolean} - true if an editing cell exist, false otherwise.\n     */\n    finishEditing: function() {\n        if (!this.get('editingAddress')) {\n            return false;\n        }\n\n        this.set('editingAddress', null);\n\n        return true;\n    },\n\n    /**\n     * Returns whether the specified cell is exist\n     * @param {String|Number} rowKey - Rowkey\n     * @param {String} columnName - ColumnName\n     * @returns {boolean} True if exist\n     * @private\n     */\n    _isValidCell: function(rowKey, columnName) {\n        var isValidRowKey = !util.isBlank(rowKey) &amp;&amp; !!this.dataModel.get(rowKey);\n        var isValidColumnName = !util.isBlank(columnName) &amp;&amp; !!this.columnModel.getColumnModel(columnName);\n\n        return isValidRowKey &amp;&amp; isValidColumnName;\n    },\n\n    /**\n     * 현재 focus 된 row 기준으로 offset 만큼 이동한 rowKey 를 반환한다.\n     * @param {Number} offset   이동할 offset\n     * @returns {?Number|String} rowKey   offset 만큼 이동한 위치의 rowKey\n     * @private\n     */\n    _findRowKey: function(offset) {\n        var dataModel = this.dataModel;\n        var rowKey = null;\n        var index, row;\n\n        if (this.has(true)) {\n            index = Math.max(\n                Math.min(\n                    dataModel.indexOfRowKey(this.get('rowKey')) + offset,\n                    this.dataModel.length - 1\n                ), 0\n            );\n            row = dataModel.at(index);\n            if (row) {\n                rowKey = row.get('rowKey');\n            }\n        }\n        return rowKey;\n    },\n\n    /**\n     * 현재 focus 된 column 기준으로 offset 만큼 이동한 columnName 을 반환한다.\n     * @param {Number} offset   이동할 offset\n     * @returns {?String} columnName  offset 만큼 이동한 위치의 columnName\n     * @private\n     */\n    _findColumnName: function(offset) {\n        var columnModel = this.columnModel;\n        var columnModelList = columnModel.getVisibleColumnModelList();\n        var columnIndex = columnModel.indexOfColumnName(this.get('columnName'), true);\n        var columnName = null;\n        var index;\n\n        if (this.has(true)) {\n            index = Math.max(Math.min(columnIndex + offset, columnModelList.length - 1), 0);\n            columnName = columnModelList[index] &amp;&amp; columnModelList[index].columnName;\n        }\n        return columnName;\n    },\n\n    /**\n     * rowSpanData 를 반환한다.\n     * @param {Number|String} rowKey    조회할 데이터의 키값\n     * @param {String} columnName   컬럼명\n     * @returns {*|{count: number, isMainRow: boolean, mainRowKey: *}|*} rowSpanData 정보\n     * @private\n     */\n    _getRowSpanData: function(rowKey, columnName) {\n        return this.dataModel.get(rowKey).getRowSpanData(columnName);\n    },\n\n    /**\n     * offset 만큼 뒤로 이동한 row 의 index 를 반환한다.\n     * @param {number} offset   이동할 offset\n     * @returns {Number} 이동한 위치의 row index\n     */\n    nextRowIndex: function(offset) {\n        var rowKey = this.nextRowKey(offset);\n\n        return this.dataModel.indexOfRowKey(rowKey);\n    },\n\n    /**\n     * offset 만큼 앞으로 이동한 row의 index를 반환한다.\n     * @param {number} offset 이동할 offset\n     * @returns {Number} 이동한 위치의 row index\n     */\n    prevRowIndex: function(offset) {\n        var rowKey = this.prevRowKey(offset);\n\n        return this.dataModel.indexOfRowKey(rowKey);\n    },\n\n    /**\n     * 다음 컬럼의 인덱스를 반환한다.\n     * @returns {Number} 다음 컬럼의 index\n     */\n    nextColumnIndex: function() {\n        var columnName = this.nextColumnName();\n\n        return this.columnModel.indexOfColumnName(columnName, true);\n    },\n\n    /**\n     * 이전 컬럼의 인덱스를 반환한다.\n     * @returns {Number} 이전 컬럼의 인덱스\n     */\n    prevColumnIndex: function() {\n        var columnName = this.prevColumnName();\n\n        return this.columnModel.indexOfColumnName(columnName, true);\n    },\n\n    /**\n     * keyEvent 발생 시 호출될 메서드로,\n     * rowSpan 정보 까지 계산된 다음 rowKey 를 반환한다.\n     * @param {number}  offset 이동할 offset\n     * @returns {Number|String} offset 만큼 이동한 위치의 rowKey\n     */\n    nextRowKey: function(offset) {\n        var focused = this.which();\n        var rowKey = focused.rowKey;\n        var count, rowSpanData;\n\n        offset = (typeof offset === 'number') ? offset : 1;\n        if (offset > 1) {\n            rowKey = this._findRowKey(offset);\n            rowSpanData = this._getRowSpanData(rowKey, focused.columnName);\n            if (!rowSpanData.isMainRow) {\n                rowKey = this._findRowKey(rowSpanData.count + offset);\n            }\n        } else {\n            rowSpanData = this._getRowSpanData(rowKey, focused.columnName);\n            if (rowSpanData.isMainRow &amp;&amp; rowSpanData.count > 0) {\n                rowKey = this._findRowKey(rowSpanData.count);\n            } else if (!rowSpanData.isMainRow) {\n                count = rowSpanData.count;\n                rowSpanData = this._getRowSpanData(rowSpanData.mainRowKey, focused.columnName);\n                rowKey = this._findRowKey(rowSpanData.count + count);\n            } else {\n                rowKey = this._findRowKey(1);\n            }\n        }\n\n        return rowKey;\n    },\n\n    /**\n     * keyEvent 발생 시 호출될 메서드로,\n     * rowSpan 정보 까지 계산된 이전 rowKey 를 반환한다.\n     * @param {number}  offset 이동할 offset\n     * @returns {Number|String} offset 만큼 이동한 위치의 rowKey\n     */\n    prevRowKey: function(offset) {\n        var focused = this.which();\n        var rowKey = focused.rowKey;\n        var rowSpanData;\n\n        offset = typeof offset === 'number' ? offset : 1;\n        offset *= -1;\n\n        if (offset &lt; -1) {\n            rowKey = this._findRowKey(offset);\n            rowSpanData = this._getRowSpanData(rowKey, focused.columnName);\n            if (!rowSpanData.isMainRow) {\n                rowKey = this._findRowKey(rowSpanData.count + offset);\n            }\n        } else {\n            rowSpanData = this._getRowSpanData(rowKey, focused.columnName);\n            if (!rowSpanData.isMainRow) {\n                rowKey = this._findRowKey(rowSpanData.count - 1);\n            } else {\n                rowKey = this._findRowKey(-1);\n            }\n        }\n\n        return rowKey;\n    },\n\n    /**\n     * keyEvent 발생 시 호출될 메서드로, 다음 columnName 을 반환한다.\n     * @returns {String} 다음 컬럼명\n     */\n    nextColumnName: function() {\n        return this._findColumnName(1);\n    },\n\n    /**\n     * keyEvent 발생 시 호출될 메서드로, 이전 columnName 을 반환한다.\n     * @returns {String} 이전 컬럼명\n     */\n    prevColumnName: function() {\n        return this._findColumnName(-1);\n    },\n\n    /**\n     * 첫번째 row 의 key 를 반환한다.\n     * @returns {(string|number)} 첫번째 row 의 키값\n     */\n    firstRowKey: function() {\n        return this.dataModel.at(0).get('rowKey');\n    },\n\n    /**\n     * 마지막 row의 key 를 반환한다.\n     * @returns {(string|number)} 마지막 row 의 키값\n     */\n    lastRowKey: function() {\n        return this.dataModel.at(this.dataModel.length - 1).get('rowKey');\n    },\n\n    /**\n     * 첫번째 columnName 을 반환한다.\n     * @returns {string} 첫번째 컬럼명\n     */\n    firstColumnName: function() {\n        var columnModelList = this.columnModel.getVisibleColumnModelList();\n\n        return columnModelList[0].columnName;\n    },\n\n    /**\n     * 마지막 columnName 을 반환한다.\n     * @returns {string} 마지막 컬럼명\n     */\n    lastColumnName: function() {\n        var columnModelList = this.columnModel.getVisibleColumnModelList();\n        var lastIndex = columnModelList.length - 1;\n\n        return columnModelList[lastIndex].columnName;\n    },\n\n    /**\n     * Returns the address of previous cell.\n     * @returns {{rowKey: number, columnName: string}}\n     */\n    prevAddress: function() {\n        var rowKey = this.get('rowKey');\n        var columnName = this.get('columnName');\n        var isFirstColumn = columnName === this.firstColumnName();\n        var isFirstRow = rowKey === this.firstRowKey();\n        var prevRowKey, prevColumnName;\n\n        if (isFirstRow &amp;&amp; isFirstColumn) {\n            prevRowKey = rowKey;\n            prevColumnName = columnName;\n        } else if (isFirstColumn) {\n            prevRowKey = this.prevRowKey();\n            prevColumnName = this.lastColumnName();\n        } else {\n            prevRowKey = rowKey;\n            prevColumnName = this.prevColumnName();\n        }\n\n        return {\n            rowKey: prevRowKey,\n            columnName: prevColumnName\n        };\n    },\n\n    /**\n     * Returns the address of next cell.\n     * @returns {{rowKey: number, columnName: string}}\n     */\n    nextAddress: function() {\n        var rowKey = this.get('rowKey');\n        var columnName = this.get('columnName');\n        var isLastColumn = columnName === this.lastColumnName();\n        var isLastRow = rowKey === this.lastRowKey();\n        var nextRowKey, nextColumnName;\n\n        if (isLastRow &amp;&amp; isLastColumn) {\n            nextRowKey = rowKey;\n            nextColumnName = columnName;\n        } else if (isLastColumn) {\n            nextRowKey = this.nextRowKey();\n            nextColumnName = this.firstColumnName();\n        } else {\n            nextRowKey = rowKey;\n            nextColumnName = this.nextColumnName();\n        }\n\n        return {\n            rowKey: nextRowKey,\n            columnName: nextColumnName\n        };\n    }\n});\n\nmodule.exports = Focus;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"