tui.util.defineNamespace("fedoc.content", {});
fedoc.content["view_layout_header.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Header View\n * @author NHN Ent. FE Development Team\n */\n'use strict';\n\nvar _ = require('underscore');\n\nvar View = require('../../base/view');\nvar util = require('../../common/util');\nvar constMap = require('../../common/constMap');\nvar classNameConst = require('../../common/classNameConst');\n\nvar DELAY_SYNC_CHECK = 10;\nvar keyCodeMap = constMap.keyCode;\nvar SEL_TYPE_COLUMN = constMap.selectionType.COLUMN;\nvar ATTR_COLUMN_NAME = constMap.attrName.COLUMN_NAME;\nvar CELL_BORDER_WIDTH = constMap.dimension.CELL_BORDER_WIDTH;\nvar TABLE_BORDER_WIDTH = constMap.dimension.TABLE_BORDER_WIDTH;\n\n/**\n * Header Layout View\n * @module view/layout/header\n * @extends module:base/view\n */\nvar Header = View.extend(/**@lends module:view/layout/header.prototype */{\n    /**\n     * @constructs\n     * @param {Object} options - options\n     * @param {String} [options.whichSide='R']  'R': Right, 'L': Left\n     */\n    initialize: function(options) {\n        View.prototype.initialize.call(this);\n\n        this.setOwnProperties({\n            renderModel: options.renderModel,\n            dimensionModel: options.dimensionModel,\n            selectionModel: options.selectionModel,\n            focusModel: options.focusModel,\n            columnModel: options.columnModel,\n            dataModel: options.dataModel,\n            viewFactory: options.viewFactory,\n            timeoutForAllChecked: 0,\n            whichSide: options.whichSide || 'R'\n        });\n\n        this.listenTo(this.renderModel, 'change:scrollLeft', this._onScrollLeftChange)\n            .listenTo(this.dimensionModel, 'columnWidthChanged', this._onColumnWidthChanged)\n            .listenTo(this.selectionModel, 'change:range', this._refreshSelectedHeaders)\n            .listenTo(this.focusModel, 'change:columnName', this._refreshSelectedHeaders)\n            .listenTo(this.dataModel, 'sortChanged', this._updateBtnSortState);\n\n        if (this.whichSide === 'L' &amp;&amp; this.columnModel.get('selectType') === 'checkbox') {\n            this.listenTo(this.dataModel,\n                'change:_button disabledChanged extraDataChanged add remove reset',\n                _.debounce(_.bind(this._syncCheckedState, this), DELAY_SYNC_CHECK));\n        }\n    },\n\n    className: classNameConst.HEAD_AREA,\n\n    events: {\n        'click': '_onClick',\n        'keydown input': '_onKeydown',\n        'mousedown th': '_onMouseDown'\n    },\n\n    /**\n     * template\n     */\n    template: _.template(\n        '&lt;table class=\"' + classNameConst.TABLE + '\">' +\n            '&lt;colgroup>&lt;%=colGroup%>&lt;/colgroup>' +\n            '&lt;tbody>&lt;%=tBody%>&lt;/tbody>' +\n        '&lt;/table>'\n    ),\n\n    /**\n     * template for &lt;th>\n     */\n    templateHeader: _.template(\n        '&lt;th &lt;%=attrColumnName%>=\"&lt;%=columnName%>\" ' +\n            'class=\"&lt;%=className%>\" ' +\n            'height=\"&lt;%=height%>\" ' +\n            '&lt;%if(colspan > 0) {%>' +\n               'colspan=&lt;%=colspan%> ' +\n            '&lt;%}%>' +\n            '&lt;%if(rowspan > 0) {%>' +\n                'rowspan=&lt;%=rowspan%> ' +\n            '&lt;%}%>' +\n        '>' +\n        '&lt;%=title%>&lt;%=btnSort%>' +\n        '&lt;/th>'\n    ),\n\n    /**\n     * templse for &lt;col>\n     */\n    templateCol: _.template(\n        '&lt;col ' +\n            '&lt;%=attrColumnName%>=\"&lt;%=columnName%>\" ' +\n            'style=\"width:&lt;%=width%>px\">'\n    ),\n\n    /**\n     * HTML string for a button\n     */\n    markupBtnSort: '&lt;a class=\"' + classNameConst.BTN_SORT + '\">&lt;/a>',\n\n    /**\n     * col group 마크업을 생성한다.\n     * @returns {string} &lt;colgroup>에 들어갈 html 마크업 스트링\n     * @private\n     */\n    _getColGroupMarkup: function() {\n        var columnData = this._getColumnData();\n        var columnWidthList = columnData.widthList;\n        var columnModelList = columnData.modelList;\n        var htmlList = [];\n\n        _.each(columnWidthList, function(width, index) {\n            htmlList.push(this.templateCol({\n                attrColumnName: ATTR_COLUMN_NAME,\n                columnName: columnModelList[index].columnName,\n                width: width + CELL_BORDER_WIDTH\n            }));\n        }, this);\n\n        return htmlList.join('');\n    },\n\n    /**\n     * Returns an array of names of columns in selection range.\n     * @private\n     * @returns {Array.&lt;String>}\n     */\n    _getSelectedColumnNames: function() {\n        var columnRange = this.selectionModel.get('range').column,\n            visibleColumns = this.columnModel.getVisibleColumnModelList(),\n            selectedColumns = visibleColumns.slice(columnRange[0], columnRange[1] + 1);\n\n        return _.pluck(selectedColumns, 'columnName');\n    },\n\n    /**\n     * Returns an array of names of merged-column which contains every column name in the given array.\n     * @param {Array.&lt;String>} columnNames - an array of column names to test\n     * @returns {Array.&lt;String>}\n     * @private\n     */\n    _getContainingMergedColumnNames: function(columnNames) {\n        var columnModel = this.columnModel,\n            mergedColumnNames = _.pluck(columnModel.get('columnMerge'), 'columnName');\n\n        return _.filter(mergedColumnNames, function(mergedColumnName) {\n            var unitColumnNames = columnModel.getUnitColumnNamesIfMerged(mergedColumnName);\n            return _.every(unitColumnNames, function(name) {\n                return _.contains(columnNames, name);\n            });\n        });\n    },\n\n    /**\n     * Refreshes selected class of every header element (th)\n     * @private\n     */\n    _refreshSelectedHeaders: function() {\n        var $ths = this.$el.find('th'),\n            columnNames, mergedColumnNames;\n\n        if (this.selectionModel.hasSelection()) {\n            columnNames = this._getSelectedColumnNames();\n        } else if (this.focusModel.has(true)) {\n            columnNames = [this.focusModel.get('columnName')];\n        }\n\n        $ths.removeClass(classNameConst.CELL_SELECTED);\n        if (columnNames) {\n            mergedColumnNames = this._getContainingMergedColumnNames(columnNames);\n            _.each(columnNames.concat(mergedColumnNames), function(columnName) {\n                $ths.filter('[' + ATTR_COLUMN_NAME + '=\"' + columnName + '\"]').addClass(classNameConst.CELL_SELECTED);\n            });\n        }\n    },\n\n    /**\n     * Event handler for 'keydown' event on checkbox input\n     * @param {KeyboardEvent} event - event\n     * @private\n     */\n    _onKeydown: function(event) {\n        if (event.keyCode === keyCodeMap.TAB) {\n            event.preventDefault();\n            this.focusModel.focusClipboard();\n        }\n    },\n\n    /**\n     * Mousedown event handler\n     * @param {jQuery.Event} event - MouseDown event\n     * @private\n     */\n    _onMouseDown: function(event) {\n        var columnName, columnNames;\n\n        if (!this.selectionModel.isEnabled() || $(event.target).is('a.' + classNameConst.BTN_SORT)) {\n            return;\n        }\n\n        columnName = $(event.target).closest('th').attr(ATTR_COLUMN_NAME);\n        if (!columnName) {\n            return;\n        }\n\n        columnNames = this.columnModel.getUnitColumnNamesIfMerged(columnName);\n\n        if (!this._hasMetaColumn(columnNames)) {\n            this._controlStartAction(columnNames, event.pageX, event.pageY, event.shiftKey);\n        }\n    },\n\n    /**\n     * Control selection action when started\n     * @param {Array} columnNames - An array of column names\n     * @param {number} pageX - Mouse position X\n     * @param {number} pageY - Mouse position Y\n     * @param {boolean} shiftKey - Whether the shift-key is pressed.\n     * @private\n     */\n    _controlStartAction: function(columnNames, pageX, pageY, shiftKey) {\n        var columnModel = this.columnModel,\n            columnIndexes = _.map(columnNames, function(name) {\n                return columnModel.indexOfColumnName(name, true);\n            });\n\n        if (shiftKey) {\n            this._startColumnSelectionWithShiftKey(columnIndexes, pageX, pageY);\n        } else {\n            this._startColumnSelectionWithoutShiftKey(columnIndexes);\n        }\n        this._attachDragEvents();\n    },\n\n    /**\n     * Start column selection with shiftKey pressed\n     * @param {Array.&lt;number>} columnIndexes - Indexes of columns\n     * @param {number} pageX - Mouse position X\n     * @param {number} pageY - Mouse position Y\n     * @private\n     */\n    _startColumnSelectionWithShiftKey: function(columnIndexes, pageX, pageY) {\n        var selectionModel = this.selectionModel;\n        var max = Math.max.apply(null, columnIndexes);\n\n        selectionModel.update(0, max, SEL_TYPE_COLUMN);\n        selectionModel.extendColumnSelection(columnIndexes, pageX, pageY);\n    },\n\n    /**\n     * Start column selection when shiftKey is not pressed\n     * @param {Array.&lt;number>} columnIndexes - Indexes of columns\n     * @private\n     */\n    _startColumnSelectionWithoutShiftKey: function(columnIndexes) {\n        var selectionModel = this.selectionModel;\n        var minMax = util.getMinMax(columnIndexes);\n        var min = minMax.min;\n        var max = minMax.max;\n\n        selectionModel.setMinimumColumnRange([min, max]);\n        selectionModel.selectColumn(min);\n        selectionModel.update(0, max);\n    },\n\n    /**\n     * Attach mouse drag event\n     * @private\n     */\n    _attachDragEvents: function() {\n        $(document)\n            .on('mousemove', $.proxy(this._onMouseMove, this))\n            .on('mouseup', $.proxy(this._detachDragEvents, this))\n            .on('selectstart', $.proxy(this._onSelectStart, this));\n    },\n\n    /**\n     * Detach mouse drag event\n     * @private\n     */\n    _detachDragEvents: function() {\n        this.selectionModel.stopAutoScroll();\n        $(document)\n            .off('mousemove', this._onMouseMove)\n            .off('mouseup', this._detachDragEvents)\n            .off('selectstart', this._onSelectStart);\n    },\n\n    /**\n     * Mousemove event handler\n     * @param {jQuery.Event} event - MouseMove event\n     * @private\n     */\n    _onMouseMove: function(event) {\n        var columnModel = this.columnModel;\n        var isExtending = true;\n        var columnName = $(event.target).closest('th').attr(ATTR_COLUMN_NAME);\n        var columnNames, columnIndexes;\n\n        if (columnName) {\n            columnNames = columnModel.getUnitColumnNamesIfMerged(columnName);\n            columnIndexes = _.map(columnNames, function(name) {\n                return columnModel.indexOfColumnName(name, true);\n            });\n        } else if ($.contains(this.el, event.target)) {\n            isExtending = false;\n        }\n\n        if (isExtending) {\n            this.selectionModel.extendColumnSelection(columnIndexes, event.pageX, event.pageY);\n        }\n    },\n\n    /**\n     * Whether this columnNames array has a meta column name.\n     * @param {Array} columnNames - An array of column names\n     * @returns {boolean} Has a meta column name or not.\n     * @private\n     */\n    _hasMetaColumn: function(columnNames) {\n        return _.some(columnNames, function(name) {\n            return util.isMetaColumn(name);\n        });\n    },\n\n    /**\n     * Selectstart event handler\n     * @param {jQuery.Event} event - Mouse event\n     * @returns {boolean} false for preventDefault\n     * @private\n     */\n    _onSelectStart: function(event) {\n        event.preventDefault();\n        return false;\n    },\n\n    /**\n     * selectType 이 checkbox 일 때 랜더링 되는 header checkbox 엘리먼트를 반환한다.\n     * @returns {jQuery} _butoon 컬럼 헤더의 checkbox input 엘리먼트\n     * @private\n     */\n    _getHeaderMainCheckbox: function() {\n        return this.$el.find('th[' + ATTR_COLUMN_NAME + '=\"_button\"] input');\n    },\n\n    /**\n     * header 영역의 input 상태를 실제 checked 된 count 에 맞추어 반영한다.\n     * @private\n     */\n    _syncCheckedState: function() {\n        var checkedState = this.dataModel.getCheckedState();\n        var $input, props;\n\n        $input = this._getHeaderMainCheckbox();\n        if (!$input.length) {\n            return;\n        }\n\n        if (!checkedState.available) {\n            props = {\n                checked: false,\n                disabled: true\n            };\n        } else {\n            props = {\n                checked: checkedState.available === checkedState.checked,\n                disabled: false\n            };\n        }\n        $input.prop(props);\n    },\n\n    /**\n     * column width 변경시 col 엘리먼트들을 조작하기 위한 헨들러\n     * @private\n     */\n    _onColumnWidthChanged: function() {\n        var columnData = this._getColumnData();\n        var columnWidthList = columnData.widthList;\n        var $colList = this.$el.find('col');\n\n        _.each(columnWidthList, function(columnWidth, index) {\n            $colList.eq(index).css('width', columnWidth + CELL_BORDER_WIDTH);\n        });\n    },\n\n    /**\n     * scroll left 값이 변경되었을 때 header 싱크를 맞추는 이벤트 핸들러\n     * @param {Object} model    변경이 발생한 model 인스턴스\n     * @param {Number} value    scrollLeft 값\n     * @private\n     */\n    /* istanbul ignore next: scrollLeft 를 확인할 수 없음 */\n    _onScrollLeftChange: function(model, value) {\n        if (this.whichSide === 'R') {\n            this.el.scrollLeft = value;\n        }\n    },\n\n    /**\n     * 클릭 이벤트 핸들러\n     * @param {jQuery.Event} clickEvent 클릭이벤트\n     * @private\n     */\n    _onClick: function(clickEvent) {\n        var $target = $(clickEvent.target);\n        var columnName = $target.closest('th').attr(ATTR_COLUMN_NAME);\n\n        if (columnName === '_button' &amp;&amp; $target.is('input')) {\n            if ($target.prop('checked')) {\n                this.dataModel.checkAll();\n            } else {\n                this.dataModel.uncheckAll();\n            }\n        } else if ($target.is('a.' + classNameConst.BTN_SORT)) {\n            this.dataModel.sortByField(columnName);\n        }\n    },\n\n    /**\n     * 정렬 버튼의 상태를 변경한다.\n     * @private\n     * @param {object} sortOptions 정렬 옵션\n     * @param {string} sortOptions.columnName 정렬할 컬럼명\n     * @param {boolean} sortOptions.isAscending 오름차순 여부\n     */\n    _updateBtnSortState: function(sortOptions) {\n        if (this._$currentSortBtn) {\n            this._$currentSortBtn.removeClass(classNameConst.BTN_SORT_DOWN + ' ' + classNameConst.BTN_SORT_UP);\n        }\n        this._$currentSortBtn = this.$el.find(\n            'th[' + ATTR_COLUMN_NAME + '=\"' + sortOptions.columnName + '\"] a.' + classNameConst.BTN_SORT\n        );\n        this._$currentSortBtn.addClass(sortOptions.isAscending ?\n            classNameConst.BTN_SORT_UP : classNameConst.BTN_SORT_DOWN\n        );\n    },\n\n    /**\n     * 랜더링\n     * @returns {View.Layout.Header} this\n     */\n    render: function() {\n        this._destroyChildren();\n\n        this.$el.css({\n            height: this.dimensionModel.get('headerHeight') - TABLE_BORDER_WIDTH\n        }).html(this.template({\n            colGroup: this._getColGroupMarkup(),\n            tBody: this._getTableBodyMarkup()\n        }));\n\n        this._addChildren(this.viewFactory.createHeaderResizeHandler(this.whichSide));\n        this.$el.append(this._renderChildren());\n        return this;\n    },\n\n    /**\n     * 컬럼 정보를 반환한다.\n     * @returns {{widthList: (Array|*), modelList: (Array|*)}}   columnWidthList 와 columnModelList 를 함께 반환한다.\n     * @private\n     */\n    _getColumnData: function() {\n        var columnModel = this.columnModel;\n        var dimensionModel = this.dimensionModel;\n        var columnWidthList = dimensionModel.getColumnWidthList(this.whichSide);\n        var columnModelList = columnModel.getVisibleColumnModelList(this.whichSide, true);\n\n        return {\n            widthList: columnWidthList,\n            modelList: columnModelList\n        };\n    },\n\n    /**\n     * Header 의 body markup 을 생성한다.\n     * @returns {string} header 의 테이블 body 영역에 들어갈 html 마크업 스트링\n     * @private\n     */\n    _getTableBodyMarkup: function() {\n        var hierarchyList = this._getColumnHierarchyList();\n        var maxRowCount = this._getHierarchyMaxRowCount(hierarchyList);\n        var headerHeight = this.dimensionModel.get('headerHeight');\n        var rowMarkupList = new Array(maxRowCount);\n        var columnNameList = new Array(maxRowCount);\n        var colSpanList = [];\n        var rowHeight = util.getRowHeight(maxRowCount, headerHeight) - 1;\n        var rowSpan = 1;\n        var height;\n        var headerMarkupList;\n\n        _.each(hierarchyList, function(hierarchy, i) {\n            var length = hierarchyList[i].length;\n            var curHeight = 0;\n\n            _.each(hierarchy, function(columnModel, j) {\n                var columnName = columnModel.columnName;\n                var classNames = [\n                    classNameConst.CELL,\n                    classNameConst.CELL_HEAD\n                ];\n\n                if (columnModel.isRequired) {\n                    classNames.push(classNameConst.CELL_REQRUIRED);\n                }\n\n                rowSpan = (length - 1 === j &amp;&amp; (maxRowCount - length + 1) > 1) ? (maxRowCount - length + 1) : 1;\n                height = rowHeight * rowSpan;\n\n                if (j === length - 1) {\n                    height = (headerHeight - curHeight) - 2;\n                } else {\n                    curHeight += height + 1;\n                }\n                if (columnNameList[j] === columnName) {\n                    rowMarkupList[j].pop();\n                    colSpanList[j] += 1;\n                } else {\n                    colSpanList[j] = 1;\n                }\n                columnNameList[j] = columnName;\n                rowMarkupList[j] = rowMarkupList[j] || [];\n                rowMarkupList[j].push(this.templateHeader({\n                    attrColumnName: ATTR_COLUMN_NAME,\n                    columnName: columnName,\n                    className: classNames.join(' '),\n                    height: height,\n                    colspan: colSpanList[j],\n                    rowspan: rowSpan,\n                    title: columnModel.title,\n                    btnSort: columnModel.isSortable ? this.markupBtnSort : ''\n                }));\n            }, this);\n        }, this);\n        headerMarkupList = _.map(rowMarkupList, function(rowMarkup) {\n            return '&lt;tr>' + rowMarkup.join('') + '&lt;/tr>';\n        });\n\n        return headerMarkupList.join('');\n    },\n\n    /**\n     * column merge 가 설정되어 있을 때 헤더의 max row count 를 가져온다.\n     * @param {Array} hierarchyList 헤더 마크업 생성시 사용될 계층구조 데이터\n     * @returns {number} 헤더 영역의 row 최대값\n     * @private\n     */\n    _getHierarchyMaxRowCount: function(hierarchyList) {\n        var lengthList = [0];\n        _.each(hierarchyList, function(hierarchy) {\n            lengthList.push(hierarchy.length);\n        }, this);\n        return Math.max.apply(Math, lengthList);\n    },\n\n    /**\n     * column merge 가 설정되어 있을 때 헤더의 계층구조 리스트를 가져온다.\n     * @returns {Array}  계층구조 리스트\n     * @private\n     */\n    _getColumnHierarchyList: function() {\n        var columnModelList = this._getColumnData().modelList,\n            hierarchyList;\n\n        hierarchyList = _.map(columnModelList, function(columnModel) {\n            return this._getColumnHierarchy(columnModel).reverse();\n        }, this);\n\n        return hierarchyList;\n    },\n\n    /**\n     * column merge 가 설정되어 있을 때 재귀적으로 돌면서 계층구조를 형성한다.\n     *\n     * @param {Object} columnModel 컬럼모델\n     * @param {Array} [resultList]  결과로 메모이제이션을 이용하기 위한 인자값\n     * @returns {Array} 계층구조 결과값\n     * @private\n     */\n    _getColumnHierarchy: function(columnModel, resultList) {\n        var columnMergeList = this.columnModel.get('columnMerge');\n        resultList = resultList || [];\n        /* istanbul ignore else */\n        if (columnModel) {\n            resultList.push(columnModel);\n            /* istanbul ignore else */\n            if (columnMergeList) {\n                _.each(columnMergeList, function(columnMerge) {\n                    if ($.inArray(columnModel.columnName, columnMerge.columnNameList) !== -1) {\n                        this._getColumnHierarchy(columnMerge, resultList);\n                    }\n                }, this);\n            }\n        }\n        return resultList;\n    }\n});\n\nHeader.DELAY_SYNC_CHECK = DELAY_SYNC_CHECK;\n\nmodule.exports = Header;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"