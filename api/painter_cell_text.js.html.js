tui.util.defineNamespace("fedoc.content", {});
fedoc.content["painter_cell_text.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Painter class for the text cell\n * @author NHN Ent. FE Development Team\n */\n'use strict';\n\nvar Cell = require('../cell');\nvar util = require('../../common/util');\nvar formUtil = require('../../common/formUtil');\n\n/**\n * Painter class for the text cell\n * @module painter/cell/text\n */\nvar TextCell = tui.util.defineClass(Cell,/**@lends module:painter/cell/text.prototype */{\n    /**\n     * @constructs\n     * @extends module:painter/cell\n     * @param {object} attributes Attributes\n     * @param {object} options Options\n     */\n    init: function(attributes, options) { // eslint-disable-line\n        Cell.apply(this, arguments);\n        this.setOwnProperties({\n            originalText: ''\n        });\n\n        this.setKeyDownSwitch({\n            'UP_ARROW': function() {},\n            'DOWN_ARROW': function() {},\n            'PAGE_UP': function() {},\n            'PAGE_DOWN': function() {},\n            'ENTER': function(keyDownEvent, param) {\n                this.focusOut(param.$target.closest('td'));\n            },\n            'ESC': function(keyDownEvent, param) {\n                this._restore(param.$target);\n                this.focusOut(param.$target.closest('td'));\n            }\n        });\n    },\n\n    redrawAttributes: ['isEditable'],\n\n    eventHandler: {\n        'blur input': '_onBlur',\n        'keydown input': '_onKeyDown',\n        'focus input': '_onFocus',\n        'selectstart input': '_onSelectStart'\n    },\n\n    /**\n     * Content markup template\n     * @return {string} html\n     */\n    contentTemplate: _.template(\n        '&lt;input' +\n        ' type=\"&lt;%=type%>\"' +\n        ' value=\"&lt;%=value%>\"' +\n        ' name=\"&lt;%=name%>\"' +\n        ' align=\"center\"' +\n        ' maxLength=\"&lt;%=maxLength%>\"' +\n        ' &lt;% if (isDisabled) print(\"disabled\"); %>' +\n        '/>'\n    ),\n\n    /**\n     * input type 을 반환한다.\n     * @return {string} input 타입\n     * @private\n     */\n    _getInputType: function() {\n        return 'text';\n    },\n\n    /**\n     * 자기 자신의 인스턴스의 editType 을 반환한다.\n     * @return {String} editType 'normal|button|select|button|text|text-password|text-convertible'\n     */\n    getEditType: function() {\n        return 'text';\n    },\n\n    /**\n     * cell 에서 키보드 enter 를 입력했을 때 편집모드로 전환. cell 내 input 에 focus 를 수행하는 로직. 필요에 따라 override 한다.\n     * @param {jQuery} $td 해당 cell 엘리먼트\n     */\n    /* istanbul ignore next: focus, select 를 검증할 수 없음 */\n    focusIn: function($td) {\n        var $input = $td.find('input');\n        if ($input.prop('disabled')) {\n            this.grid.focusModel.focusClipboard();\n        } else {\n            formUtil.setCursorToEnd($input.get(0));\n            $input.select();\n        }\n    },\n\n    /**\n     * focus in 상태에서 키보드 esc 를 입력했을 때 편집모드를 벗어난다. cell 내 input 을 blur 시키고, 편집모드를 벗어나는 로직.\n     * - 필요에 따라 override 한다.\n     */\n    focusOut: function() {\n        this.grid.focusModel.focusClipboard();\n    },\n\n    /**\n     * Cell data 를 인자로 받아 &lt;td> 안에 들아갈 html string 을 반환한다.\n     * redrawAttributes 에 해당하는 프로퍼티가 변경되었을 때 수행될 로직을 구현한다.\n     * @param {object} cellData 모델의 셀 데이터\n     * @return  {string} html 마크업 문자열\n     * @example\n     * var html = this.getContentHtml();\n     * &lt;select>\n     *     &lt;option value='1'>option1&lt;/option>\n     *     &lt;option value='2'>option1&lt;/option>\n     *     &lt;option value='3'>option1&lt;/option>\n     * &lt;/select>\n     */\n    getContentHtml: function(cellData) {\n        //@fixme: defaultValue 옵션값 처리 (cellData.value 를 참조하도록)\n        var columnModel = this.getColumnModel(cellData),\n            editOption = columnModel.editOption,\n            value = this.grid.dataModel.get(cellData.rowKey).getHTMLEncodedString(cellData.columnName),\n            html;\n\n        if (tui.util.isUndefined(value)) {\n            value = '';\n        }\n        html = this._getConvertedHtml(value, cellData);\n\n        if (tui.util.isNull(html)) {\n            html = this.contentTemplate({\n                type: this._getInputType(),\n                value: value,\n                name: util.getUniqueKey(),\n                isDisabled: cellData.isDisabled,\n                maxLength: editOption.maxLength\n            });\n        }\n        return html;\n    },\n\n    /**\n     * model의 redrawAttributes 에 해당하지 않는 프로퍼티의 변화가 발생했을 때 수행할 메서드\n     * redrawAttributes 에 해당하지 않는 프로퍼티가 변경되었을 때 수행할 로직을 구현한다.\n     * @param {object} cellData 모델의 셀 데이터\n     * @param {jQuery} $td 해당 cell 엘리먼트\n     */\n    setElementAttribute: function(cellData, $td) {\n        var isValueChanged = $.inArray('value', cellData.changed) !== -1,\n            $input = $td.find('input');\n\n        if (isValueChanged) {\n            $input.val(cellData.value);\n        }\n        $input.prop('disabled', cellData.isDisabled);\n    },\n\n    /**\n     * 원래 text 와 비교하여 값이 변경 되었는지 여부를 판단한다.\n     * @param {jQuery} $input   인풋 jquery 엘리먼트\n     * @return {Boolean}    값의 변경여부\n     * @private\n     */\n    _isEdited: function($input) {\n        return $input.val() !== this.originalText;\n    },\n\n    /**\n     * 원래 text로 값을 되돌린다.\n     * @param {jQuery} $input 인풋 jquery 엘리먼트\n     * @private\n     */\n    _restore: function($input) {\n        $input.val(this.originalText);\n    },\n\n    /**\n     * 각 셀 페인터 인스턴스마다 정의된 getContentHtml 을 이용하여\n     * 컬럼모델의 defaultValue, beforeText, afterText 를 적용한 content html 마크업 스트링 을 반환한다.\n     * (Input의 width를 beforeText와 afterText의 유무에 관계없이 100%로 유지하기 위해 마크업이 달라져야 하기 때문에\n     * Painter.Cell로부터 override 해서 구현함)\n     * @param {object} cellData Model 의 셀 데이터\n     * @return {string} 컬럼모델의 defaultValue, beforeText, afterText 를 적용한 content html 마크업 스트링\n     * @private\n     * @override\n     */\n    _getContentHtml: function(cellData) {\n        var columnName = cellData.columnName,\n            columnModel = this.grid.columnModel.getColumnModel(columnName),\n            editOption = columnModel.editOption || {},\n            content = '',\n            beforeContent, afterContent;\n\n        if (!tui.util.isExisty(cellData.value)) {\n            cellData.value = columnModel.defaultValue;\n        }\n        beforeContent = this._getExtraContent(editOption.beforeContent || editOption.beforeText, cellData);\n        afterContent = this._getExtraContent(editOption.afterContent || editOption.afterText, cellData);\n\n        if (beforeContent) {\n            content += this._getSpanWrapContent(beforeContent, 'before', cellData);\n        }\n        if (afterContent) {\n            content += this._getSpanWrapContent(afterContent, 'after', cellData);\n        }\n        content += this._getSpanWrapContent(this.getContentHtml(cellData), 'input');\n\n        return content;\n    },\n\n    /**\n     * blur 이벤트 핸들러\n     * @param {Event} blurEvent 이벤트 객체\n     * @private\n     */\n    _onBlur: function(blurEvent) {\n        var $target = $(blurEvent.target),\n            rowKey = this.getRowKey($target),\n            columnName = this.getColumnName($target);\n\n        this._executeInputEventHandler(blurEvent, 'blur');\n        if (this._isEdited($target)) {\n            this.grid.dataModel.setValue(rowKey, columnName, $target.val());\n        }\n        this.grid.selectionModel.enable();\n    },\n\n    /**\n     * focus 이벤트 핸들러\n     * @param {Event} focusEvent 이벤트 객체\n     * @private\n     */\n    _onFocus: function(focusEvent) {\n        var $input = $(focusEvent.target);\n\n        this.originalText = $input.val();\n        this._executeInputEventHandler(focusEvent, 'focus');\n        this.grid.selectionModel.end();\n    },\n\n    /**\n     * keydown 이벤트 핸들러\n     * @param  {KeyboardEvent} keyboardEvent 키보드 이벤트 객체\n     * @private\n     */\n    _onKeyDown: function(keyboardEvent) {\n        this._executeInputEventHandler(keyboardEvent, 'keydown');\n        Cell.prototype._onKeyDown.call(this, keyboardEvent);\n    },\n\n    /**\n     * 해당 input 요소가 포함된 셀을 찾아 rowKey와 columnName을 객체로 반환한다.\n     * @param  {jQuery} $input - 인풋 요소의 jquery 객체\n     * @return {{rowKey: number, columnName: number}} 셀의 rowKey, columnName 정보\n     * @private\n     */\n    _getCellInfoFromInput: function($input) {\n        var $cell = $input.closest('td'),\n            $row = $cell.closest('tr');\n\n        return {\n            rowKey: $row.attr('key'),\n            columnName: $cell.attr('columnname')\n        };\n    },\n\n    /**\n     * event 객체가 발생한 셀을 찾아 editOption에 inputEvent 핸들러 정보가 설정되어 있으면\n     * 해당 이벤트 핸들러를 호출해준다.\n     * @param {Event} event - 이벤트 객체\n     * @param {string} eventName - 이벤트명\n     * @return {boolean} Return value of the event handler. Null if there's no event handler.\n     * @private\n     */\n    _executeInputEventHandler: function(event, eventName) {\n        var $input = $(event.target),\n            cellInfo = this._getCellInfoFromInput($input),\n            columnModel = this.grid.columnModel.getColumnModel(cellInfo.columnName),\n            eventHandler = tui.util.pick(columnModel, 'editOption', 'inputEvents', eventName);\n\n        if (_.isFunction(eventHandler)) {\n            return eventHandler(event, cellInfo);\n        }\n        return null;\n    },\n\n    /**\n     * selectstart 이벤트 핸들러\n     * IE에서 selectstart 이벤트가 Input 요소에 까지 적용되어 값에 셀렉션 지정이 안되는 문제를 해결\n     * @param {Event} event 이벤트 객체\n     * @private\n     */\n    _onSelectStart: function(event) {\n        event.stopPropagation();\n    }\n});\n\nmodule.exports = TextCell;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"