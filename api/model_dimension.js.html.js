ne.util.defineNamespace("fedoc.content", {});
fedoc.content["model_dimension.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview 크기에 관련된 데이터를 다루는 모델\n * @author NHN Ent. FE Development Team\n */\n'use strict';\n\nvar Model = require('../base/model');\nvar util = require('../util');\n\n// The width of the border of the dimension.\nvar BORDER_WIDTH = 1;\n\n// The width of the border of table cell.\nvar CELL_BORDER_WIDTH = 1;\n\n/**\n * 크기 관련 데이터 저장\n * @module model/dimension\n */\nvar Dimension = Model.extend(/**@lends module:model/dimension.prototype */{\n    /**\n     * @extends module:base/model\n     * @constructs\n     */\n    initialize: function() {\n        Model.prototype.initialize.apply(this, arguments);\n\n        /**\n         * An array of the fixed flags of the columns\n         * @private\n         * @type {boolean[]}\n         */\n        this._columnWidthFixedFlags = null;\n\n        /**\n         * An array of the minimum width of the columns\n         * @private\n         * @type {number[]}\n         */\n        this._minColumnWidthList = null;\n        this.columnModel = this.grid.columnModel;\n\n        this.listenTo(this.columnModel, 'columnModelChange', this._initColumnWidthVariables);\n        this.listenTo(this.grid.dataModel, 'add remove reset', this._resetTotalRowHeight);\n\n        this.on('change:width', this._onWidthChange, this);\n        this.on('change:displayRowCount', this._setBodyHeight, this);\n\n        this._initColumnWidthVariables();\n        this._initToolbarHeight();\n        this._setBodyHeight();\n    },\n\n    models: null,\n\n    columnModel: null,\n\n    defaults: {\n        offsetLeft: 0,\n        offsetTop: 0,\n\n        width: 0,\n\n        headerHeight: 0,\n        bodyHeight: 0,\n        toolbarHeight: 65,\n\n        rowHeight: 0,\n        totalRowHeight: 0,\n\n        rsideWidth: 0,\n        lsideWidth: 0,\n        columnWidthList: [],\n\n        minimumColumnWidth: 0,\n        displayRowCount: 1,\n        scrollBarSize: 17,\n        scrollX: true,\n        scrollY: true\n    },\n\n    /**\n     * 전체 넓이에서 스크롤바, border등의 넓이를 제외하고 실제 셀의 넓이에 사용되는 값만 반환한다.\n     * @param {number} columnLength - 컬럼의 개수\n     * @return {number} 사용가능한 전체 셀의 넓이\n     * @private\n     */\n    _getAvailableTotalWidth: function(columnLength) {\n        var totalWidth = this.get('width'),\n            availableTotalWidth = totalWidth - columnLength - 1;\n\n        if (this.get('scrollY')) {\n            availableTotalWidth -= this.get('scrollBarSize');\n        }\n        if (this.columnModel.getVisibleColumnFixCount(true) > 0) {\n            availableTotalWidth -= CELL_BORDER_WIDTH;\n        }\n        return availableTotalWidth;\n    },\n\n    /**\n     * Makes all width of columns not less than minimumColumnWidth.\n     * @param {number[]} columnWidthList - 컬럼 넓이값 배열\n     * @return {number[]} - 수정된 새로운 넓이값 배열\n     * @private\n     */\n    _applyMinimumColumnWidth: function(columnWidthList) {\n        var minWidthList = this._minColumnWidthList,\n            appliedList = _.clone(columnWidthList);\n\n        _.each(appliedList, function(width, index) {\n            var minWidth = minWidthList[index];\n            if (width &lt; minWidth) {\n                appliedList[index] = minWidth;\n            }\n        });\n        return appliedList;\n    },\n\n    /**\n     * Reset 'totalRowHeight' property.\n     */\n    _resetTotalRowHeight: function() {\n        var rowHeight = this.get('rowHeight'),\n            rowCount = this.grid.dataModel.length,\n            totalBorderWidth = rowCount + 1;\n\n        this.set('totalRowHeight', (rowHeight * rowCount) + totalBorderWidth);\n    },\n\n    /**\n     * Sets the toolbar height to 0 if the toolbar option has no value.\n     */\n    _initToolbarHeight: function() {\n        var option = this.grid.option('toolbar');\n        if (!option || (!option.hasPagination &amp;&amp; !option.hasControlPanel &amp;&amp; !option.hasResizeHandler)) {\n            this.set('toolbarHeight', 0);\n        }\n    },\n\n    /**\n     * Sets the width of columns whose width is not assigned by distributing extra width to them equally.\n     * @param {number[]} columnWidthList - An array of column widths\n     * @return {number[]} - A new array of column widths\n     * @private\n     */\n    _fillEmptyColumnWidth: function(columnWidthList) {\n        var totalWidth = this._getAvailableTotalWidth(columnWidthList.length),\n            remainTotalWidth = totalWidth - util.sum(columnWidthList),\n            emptyIndexes = [];\n\n        _.each(columnWidthList, function(width, index) {\n            if (!width) {\n                emptyIndexes.push(index);\n            }\n        });\n        return this._distributeExtraWidthEqually(columnWidthList, remainTotalWidth, emptyIndexes);\n    },\n\n    /**\n     * Adds extra widths of the column equally.\n     * @param {number[]} columnWidthList - An array of column widths\n     * @param {number} totalExtraWidth - Total extra width\n     * @return {number[]} - A new array of column widths\n     * @private\n     */\n    _addExtraColumnWidth: function(columnWidthList, totalExtraWidth) {\n        var fixedFlags = this._columnWidthFixedFlags,\n            columnIndexes = [];\n\n        _.each(fixedFlags, function(flag, index) {\n            if (!flag) {\n                columnIndexes.push(index);\n            }\n        });\n        return this._distributeExtraWidthEqually(columnWidthList, totalExtraWidth, columnIndexes);\n    },\n\n    /**\n     * Reduces excess widths of the column equally.\n     * @param {number[]} columnWidthList - An array of column widths\n     * @param {number} totalExcessWidth - Total excess width (negative number)\n     * @return {number[]} - A new array of column widths\n     * @private\n     */\n    _reduceExcessColumnWidth: function(columnWidthList, totalExcessWidth) {\n        var minWidthList = this._minColumnWidthList,\n            fixedFlags = this._columnWidthFixedFlags,\n            availableList = [];\n\n        _.each(columnWidthList, function(width, index) {\n            if (!fixedFlags[index]) {\n                availableList.push({\n                    index: index,\n                    width: width - minWidthList[index]\n                });\n            }\n        });\n        return this._reduceExcessColumnWidthSub(_.clone(columnWidthList), totalExcessWidth, availableList);\n    },\n\n    /**\n     * Reduce the (remaining) excess widths of the column.\n     * This method will be called recursively by _reduceExcessColumnWidth.\n     * @param {number[]} columnWidthList - An array of column Width\n     * @param {number} totalRemainWidth - Remaining excess width (negative number)\n     * @param {object[]} availableList - An array of infos about available column.\n     *                                 Each item of the array has {index:number, width:number}.\n     * @return {number[]} - A new array of column widths\n     * @private\n     */\n    _reduceExcessColumnWidthSub: function(columnWidthList, totalRemainWidth, availableList) {\n        var avgValue = Math.round(totalRemainWidth / availableList.length),\n            newAvailableList = [],\n            columnIndexes;\n\n        _.each(availableList, function(available) {\n            // note that totalRemainWidth and avgValue are negative number.\n            if (available.width &lt; Math.abs(avgValue)) {\n                totalRemainWidth += available.width;\n                columnWidthList[available.index] -= available.width;\n            } else {\n                newAvailableList.push(available);\n            }\n        });\n        // call recursively until all available width are less than average\n        if (availableList.length > newAvailableList.length) {\n            return this._reduceExcessColumnWidthSub(columnWidthList, totalRemainWidth, newAvailableList);\n        }\n        columnIndexes = _.pluck(availableList, 'index');\n        return this._distributeExtraWidthEqually(columnWidthList, totalRemainWidth, columnIndexes);\n    },\n\n    /**\n     * Distributes the extra width equally to each column at specified indexes.\n     * @param {number[]} columnWidthList - An array of column width\n     * @param {number} extraWidth - Extra width\n     * @param {number[]} columnIndexes - An array of indexes of target columns\n     * @return {number[]} - A new array of column widths\n     * @private\n     */\n    _distributeExtraWidthEqually: function(columnWidthList, extraWidth, columnIndexes) {\n        var length = columnIndexes.length,\n            avgValue = Math.round(extraWidth / length),\n            errorValue = (avgValue * length) - extraWidth, // to correct total width\n            resultList = _.clone(columnWidthList);\n\n        _.each(columnIndexes, function(columnIndex) {\n            resultList[columnIndex] += avgValue;\n        });\n        resultList[_.last(columnIndexes)] -= errorValue;\n\n        return resultList;\n    },\n\n    /**\n     * Adjust the column widths to make them fit into the dimension.\n     * @param {number[]} columnWidthList - An array of column width\n     * @param {boolean} [fitToReducedTotal] - If set to true and the total width is smaller than dimension(width),\n     *                                    the column widths will be reduced.\n     * @return {number[]} - A new array of column widths\n     * @private\n     */\n    _adjustColumnWidthList: function(columnWidthList, fitToReducedTotal) {\n        var columnLength = columnWidthList.length,\n            availableWidth = this._getAvailableTotalWidth(columnLength),\n            totalExtraWidth = availableWidth - util.sum(columnWidthList),\n            fixedCount = _.filter(this._columnWidthFixedFlags).length,\n            adjustedList;\n\n        if (totalExtraWidth > 0) {\n            if (columnLength > fixedCount) {\n                adjustedList = this._addExtraColumnWidth(columnWidthList, totalExtraWidth);\n            } else {\n                // If all column has fixed width, add extra width to the last column.\n                adjustedList = _.clone(columnWidthList);\n                adjustedList[columnLength - 1] += totalExtraWidth;\n            }\n        } else if (fitToReducedTotal &amp;&amp; totalExtraWidth &lt; 0) {\n            adjustedList = this._reduceExcessColumnWidth(columnWidthList, totalExtraWidth);\n        } else {\n            adjustedList = columnWidthList;\n        }\n        return adjustedList;\n    },\n\n    /**\n     * columnModel 에 설정된 넓이값을 기준으로 컬럼넓이와 관련된 변수들의 값을 초기화한다.\n     * @private\n     */\n    _initColumnWidthVariables: function() {\n        var columnModelList = this.columnModel.getVisibleColumnModelList(null, true),\n            commonMinWidth = this.get('minimumColumnWidth'),\n            widthList = [],\n            fixedFlags = [],\n            minWidthList = [],\n            calculate;\n\n        _.each(columnModelList, function(columnModel) {\n            var width = columnModel.width > 0 ? columnModel.width : 0,\n                minWidth = Math.max(width, commonMinWidth);\n            // If the width is not assigned (not positive number), set it to zero (not applying minimum width)\n            // so that #_fillEmptyColumnWidth() can detect which one is empty.\n            // After then, minimum width will be applied by #_applyMinimumColumnWidth().\n            widthList.push(width ? minWidth : 0);\n            minWidthList.push(minWidth);\n            fixedFlags.push(!!columnModel.isFixedWidth);\n        });\n\n        this._columnWidthFixedFlags = fixedFlags;\n        this._minColumnWidthList = minWidthList;\n\n        // note that the calling order of functions is bottom-to-top.\n        calculate = _.compose(\n            this._adjustColumnWidthList,\n            this._applyMinimumColumnWidth,\n            this._fillEmptyColumnWidth\n        );\n        this._setColumnWidthVariables(calculate.call(this, widthList), true);\n    },\n\n    /**\n     * L, R 중 하나를 입력받아 frame 의 너비를 구한다.\n     * @param {String} [whichSide]  지정하지 않을 경우 전체 너비.\n     * @return {Number} 해당 frame 의 너비\n     */\n    getFrameWidth: function(whichSide) {\n        var columnFixCount = this.columnModel.getVisibleColumnFixCount(true),\n            columnWidthList = this.getColumnWidthList(whichSide),\n            frameWidth = this._getFrameWidth(columnWidthList);\n        if (tui.util.isUndefined(whichSide) &amp;&amp; columnFixCount > 0) {\n            //columnFixCount 가 0보다 클 경우, 열고정 되어있기 때문에, 경계영역에 대한 1px도 함께 더한다.\n            frameWidth += 1;\n        }\n        return frameWidth;\n    },\n\n    /**\n     * widthList 로부터 보더 값을 포함하여 계산한 frameWidth 를 구한다.\n     * @param {Array} widthList 너비 리스트 배열\n     * @return {Number} 계산된 frame 너비값\n     * @private\n     */\n    _getFrameWidth: function(widthList) {\n        var frameWidth = 0;\n        if (widthList.length) {\n            frameWidth = util.sum(widthList) + ((widthList.length + 1) * CELL_BORDER_WIDTH);\n        }\n        return frameWidth;\n    },\n\n    /**\n     * columnWidthList 로 부터, lside 와 rside 의 전체 너비를 계산하여 저장한다.\n     * @param {array} columnWidthList - 컬럼 넓이값 배열\n     * @param {boolean} [isSaveWidthList] - 저장 여부. true이면 넓이값 배열을 originalWidthList로 저장한다.\n     * @private\n     */\n    _setColumnWidthVariables: function(columnWidthList, isSaveWidthList) {\n        var totalWidth = this.get('width'),\n            columnFixCount = this.columnModel.getVisibleColumnFixCount(true),\n            maxLeftSideWidth = this._getMaxLeftSideWidth(),\n            rsideWidth, lsideWidth, lsideWidthList, rsideWidthList;\n\n        lsideWidthList = columnWidthList.slice(0, columnFixCount);\n        rsideWidthList = columnWidthList.slice(columnFixCount);\n\n        lsideWidth = this._getFrameWidth(lsideWidthList);\n        if (maxLeftSideWidth &amp;&amp; maxLeftSideWidth &lt; lsideWidth) {\n            lsideWidthList = this._adjustLeftSideWidthList(lsideWidthList, maxLeftSideWidth);\n            lsideWidth = this._getFrameWidth(lsideWidthList);\n            columnWidthList = lsideWidthList.concat(rsideWidthList);\n        }\n        rsideWidth = totalWidth - lsideWidth;\n\n        this.set({\n            columnWidthList: columnWidthList,\n            rsideWidth: rsideWidth,\n            lsideWidth: lsideWidth\n        });\n\n        if (isSaveWidthList) {\n            this.set('originalWidthList', _.clone(columnWidthList));\n        }\n        this.trigger('columnWidthChanged');\n    },\n\n    /**\n     * 열 고정 영역의 minimum width 값을 구한다.\n     * @return {number} 열고정 영역의 최소 너비값.\n     * @private\n     */\n    _getMinLeftSideWidth: function() {\n        var minimumColumnWidth = this.get('minimumColumnWidth'),\n            columnFixCount = this.columnModel.getVisibleColumnFixCount(true),\n            minWidth = 0,\n            borderWidth;\n\n        if (columnFixCount) {\n            borderWidth = (columnFixCount + 1) * CELL_BORDER_WIDTH;\n            minWidth = borderWidth + (minimumColumnWidth * columnFixCount);\n        }\n        return minWidth;\n    },\n\n    /**\n     * 열 고정 영역의 maximum width 값을 구한다.\n     * @return {number} 열고정 영역의 최대 너비값.\n     * @private\n     */\n    _getMaxLeftSideWidth: function() {\n        var maxWidth = Math.ceil(this.get('width') * 0.9);\n\n        if (maxWidth) {\n            maxWidth = Math.max(maxWidth, this._getMinLeftSideWidth());\n        }\n        return maxWidth;\n    },\n\n    /**\n     * 계산한 cell 의 위치를 리턴한다.\n     * @param {Number|String} rowKey - 데이터의 키값\n     * @param {String} columnName - 칼럼명\n     * @return {{top: number, left: number, right: number, bottom: number}} - cell의 위치\n     */\n    getCellPosition: function(rowKey, columnName) {\n        var dataModel = this.grid.dataModel,\n            columnModel = this.grid.columnModel,\n            rowHeight = this.get('rowHeight'),\n            rowSpanData = dataModel.get(rowKey).getRowSpanData(columnName),\n            rowIdx, spanCount,\n            metaColumnCount = columnModel.getVisibleMetaColumnCount(),\n            columnWidthList = this.get('columnWidthList').slice(metaColumnCount),\n            columnFixCount = columnModel.getVisibleColumnFixCount(),\n            columnIdx = columnModel.indexOfColumnName(columnName, true),\n            top, left, right, bottom, i;\n\n        if (!rowSpanData.isMainRow) {\n            rowKey = rowSpanData.mainRowKey;\n            rowSpanData = dataModel.get(rowKey).getRowSpanData(columnName);\n        }\n\n        spanCount = rowSpanData.count || 1;\n\n        rowIdx = dataModel.indexOfRowKey(rowKey);\n\n        top = util.getHeight(rowIdx, rowHeight);\n        bottom = top + util.getHeight(spanCount, rowHeight) - CELL_BORDER_WIDTH;\n\n        left = i = 0;\n        if (columnFixCount &lt;= columnIdx) {\n            i = columnFixCount;\n        }\n        for (; i &lt; columnIdx; i += 1) {\n            left += columnWidthList[i] + CELL_BORDER_WIDTH;\n        }\n        right = left + columnWidthList[i] + CELL_BORDER_WIDTH;\n\n        return {\n            top: top,\n            left: left,\n            right: right,\n            bottom: bottom\n        };\n    },\n\n    /**\n     * columnFixCount 가 적용되었을 때, window resize 시 left side 의 너비를 조정한다.\n     * @param {Array} lsideWidthList    열고정 영역의 너비 리스트 배열\n     * @param {Number} totalWidth   grid 전체 너비\n     * @return {Array} 열고정 영역의 너비 리스트\n     * @private\n     */\n    _adjustLeftSideWidthList: function(lsideWidthList, totalWidth) {\n        var i = lsideWidthList.length - 1,\n            minimumColumnWidth = this.get('minimumColumnWidth'),\n            currentWidth = this._getFrameWidth(lsideWidthList),\n            diff = currentWidth - totalWidth,\n            changedWidth;\n        if (diff > 0) {\n            while (i >= 0 &amp;&amp; diff > 0) {\n                changedWidth = Math.max(minimumColumnWidth, lsideWidthList[i] - diff);\n                diff -= lsideWidthList[i] - changedWidth;\n                lsideWidthList[i] = changedWidth;\n                i -= 1;\n            }\n        } else if (diff &lt; 0) {\n            lsideWidthList[i] += Math.abs(diff);\n        }\n        return lsideWidthList;\n    },\n\n    /**\n     * 그리드의 body height 를 계산하여 할당한다.\n     * @private\n     */\n    _setBodyHeight: function() {\n        var height = util.getHeight(this.get('displayRowCount'), this.get('rowHeight'));\n        if (this.get('scrollX')) {\n            height += this.get('scrollBarSize');\n        }\n        this.set('bodyHeight', height);\n    },\n\n    /**\n     * 현재 화면에 보이는 row 개수를 반환\n     * @return {number} 화면에 보이는 행 개수\n     */\n    getDisplayRowCount: function() {\n        return util.getDisplayRowCount(this.get('bodyHeight') - this.getScrollXHeight(), this.get('rowHeight'));\n    },\n\n    /**\n     * 수평 스크롤바의 높이를 구한다. 수평 스크롤바를 사용하지 않을 경우 0을 반환한다.\n     * @return {number} 수평 스크롤바의 높이\n     */\n    getScrollXHeight: function() {\n        return +this.get('scrollX') * this.get('scrollBarSize');\n    },\n\n    /**\n     * width 값 변경시 각 column 별 너비를 계산한다.\n     * @private\n     */\n    _onWidthChange: function() {\n        var widthList = this._adjustColumnWidthList(this.get('columnWidthList'), true);\n        this._setColumnWidthVariables(widthList);\n    },\n\n    /**\n     * columnResize 발생 시 index 에 해당하는 컬럼의 width 를 변경하여 반영한다.\n     * @param {Number} index    너비를 변경할 컬럼의 인덱스\n     * @param {Number} width    변경할 너비 pixel값\n     */\n    setColumnWidth: function(index, width) {\n        var columnWidthList = this.get('columnWidthList'),\n            fixedFlags = this._columnWidthFixedFlags,\n            minWidth = this._minColumnWidthList[index],\n            adjustedList;\n\n        if (!fixedFlags[index] &amp;&amp; columnWidthList[index]) {\n            columnWidthList[index] = Math.max(width, minWidth);\n            // makes width of the target column fixed temporarily\n            // to not be influenced while adjusting column widths.\n            fixedFlags[index] = true;\n            adjustedList = this._adjustColumnWidthList(columnWidthList);\n            fixedFlags[index] = false;\n            this._setColumnWidthVariables(adjustedList);\n        }\n    },\n\n    /**\n     * Returns the height of table body.\n     * @param  {number} height - The height of the dimension\n     * @return {number} The height of the table body\n     * @private\n     */\n    _getBodyHeight: function(height) {\n        return height - this.get('headerHeight') - this.get('toolbarHeight') - BORDER_WIDTH;\n    },\n\n    /**\n     * Returns the minimum height of table body.\n     * @return {number} The minimum height of table body\n     * @private\n     */\n    _getMinBodyHeight: function() {\n        return this.get('rowHeight') + (CELL_BORDER_WIDTH * 2) + this.getScrollXHeight();\n    },\n\n    /**\n     * Sets the height of the dimension.\n     * (Resets the bodyHeight and displayRowCount relative to the dimension height)\n     * @param  {number} height - The height of the dimension\n     */\n    setHeight: function(height) {\n        this.set('bodyHeight', Math.max(this._getBodyHeight(height), this._getMinBodyHeight()));\n        this.set('displayRowCount', this.getDisplayRowCount(), {silent: true});\n    },\n\n    /**\n     * 초기 너비로 돌린다.\n     * @param {Number} index    너비를 변경할 컬럼의 인덱스\n     */\n    restoreColumnWidth: function(index) {\n        var orgWidth = this.get('originalWidthList')[index];\n        this.setColumnWidth(index, orgWidth);\n    },\n\n    /**\n     * L side 와 R side 에 따른 columnWidthList 를 반환한다.\n     * @param {String} [whichSide] 어느 영역인지 여부. 'L|R' 중 하나를 인자로 넘긴다. 생략시 전체 columnList 반환\n     * @return {Array}  조회한 영역의 columnWidthList\n     */\n    getColumnWidthList: function(whichSide) {\n        var columnFixCount = this.columnModel.getVisibleColumnFixCount(true),\n            columnWidthList = [];\n\n        switch (whichSide) {\n            case 'l':\n            case 'L':\n                columnWidthList = this.get('columnWidthList').slice(0, columnFixCount);\n                break;\n            case 'r':\n            case 'R':\n                columnWidthList = this.get('columnWidthList').slice(columnFixCount);\n                break;\n            default :\n                columnWidthList = this.get('columnWidthList');\n                break;\n        }\n        return columnWidthList;\n    }\n});\n\nmodule.exports = Dimension;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"