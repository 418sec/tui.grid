ne.util.defineNamespace("fedoc.content", {});
fedoc.content["core.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Grid Core 파일\n * @author NHN Ent. FE Development Team\n */\n 'use strict';\n\nvar View = require('./base/view');\n\n// data models\nvar ColumnModelData = require('./data/columnModel');\nvar RowListData = require('./data/rowList');\n\n// models\nvar DimensionModel = require('./model/dimension');\nvar FocusModel = require('./model/focus');\nvar RenderModel = require('./model/renderer');\nvar SmartRenderModel = require('./model/renderer-smart');\nvar SelectionModel = require('./model/selection');\n\n// views\nvar CellFactory = require('./view/cellFactory');\nvar Clipboard = require('./view/clipboard');\n\n// layouts\nvar LsideFrame = require('./view/layout/frame-lside');\nvar RsideFrame = require('./view/layout/frame-rside');\nvar ToolbarLayout = require('./view/layout/toolbar');\n\n// layers\nvar ReadyLayer = require('./view/layer/ready');\nvar EmptyLayer = require('./view/layer/empty');\nvar LoadingLayer = require('./view/layer/loading');\n\nvar Net = require('./addon/net');\nvar util = require('./util');\n\nvar addOn = {\n    Net: Net\n};\n\n/**\n * Grid Core\n * @module core\n */\nvar Core = View.extend(/**@lends module:core.prototype */{\n    /**\n     * @constructs\n     * @extends module:base/view\n     * @param {Object} options Grid.js 의 생성자 option 과 동일값.\n     */\n    initialize: function(options) {\n        var id = util.getUniqueKey();\n\n        View.prototype.initialize.apply(this, arguments);\n\n        this.publicInstance = options.publicInstance;\n        this.__instance[id] = this;\n        this.id = id;\n\n        this._initializeOptions(options);\n        this._initializeProperties();\n\n        this._initializeModel();\n        this._initializeListener();\n        this._initializeView();\n\n        this._attachExtraEvent();\n\n        this.render();\n\n        this.updateLayoutData();\n    },\n\n    /**\n     * 스크롤바의 높이\n     * @type {Number}\n     */\n    scrollBarSize: 17,\n\n    lside: null,\n\n    rside: null,\n\n    toolbar: null,\n\n    cellFactory: null,\n\n    events: {\n        'click': '_onClick',\n        'dblclick': '_onDblClick',\n        'mousedown': '_onMouseDown',\n        'selectstart': '_preventDrag',\n        'dragstart': '_preventDrag',\n        'mouseover': '_onMouseOver',\n        'mouseout': '_onMouseOut'\n    },\n\n    keyMap: {\n        'TAB': 9,\n        'ENTER': 13,\n        'CTRL': 17,\n        'ESC': 27,\n        'LEFT_ARROW': 37,\n        'UP_ARROW': 38,\n        'RIGHT_ARROW': 39,\n        'DOWN_ARROW': 40,\n        'CHAR_A': 65,\n        'CHAR_C': 67,\n        'CHAR_F': 70,\n        'CHAR_R': 82,\n        'CHAR_V': 86,\n        'LEFT_WINDOW_KEY': 91,\n        'F5': 116,\n        'BACKSPACE': 8,\n        'SPACE': 32,\n        'PAGE_UP': 33,\n        'PAGE_DOWN': 34,\n        'HOME': 36,\n        'END': 35,\n        'DEL': 46,\n        'UNDEFINED': 229\n    },\n\n    keyName: {\n        9: 'TAB',\n        13: 'ENTER',\n        17: 'CTRL',\n        27: 'ESC',\n        37: 'LEFT_ARROW',\n        38: 'UP_ARROW',\n        39: 'RIGHT_ARROW',\n        40: 'DOWN_ARROW',\n        65: 'CHAR_A',\n        67: 'CHAR_C',\n        70: 'CHAR_F',\n        82: 'CHAR_R',\n        86: 'CHAR_V',\n        91: 'LEFT_WINDOW_KEY',\n        116: 'F5',\n        8: 'BACKSPACE',\n        32: 'SPACE',\n        33: 'PAGE_UP',\n        34: 'PAGE_DOWN',\n        36: 'HOME',\n        35: 'END',\n        46: 'DEL',\n        229: 'UNDEFINED'\n    },\n\n    /**\n     * default 설정된 옵션에서 생성자로부터 인자로 받은 옵션들을 확장하여 옵션을 설정한다.\n     * @param {Object} options Grid.js 의 생성자 option 과 동일값.\n     * @private\n     */\n    _initializeOptions: function(options) {\n        var defaultOptions = {\n            columnFixCount: 0,\n            columnModelList: [],\n            keyColumnName: null,\n            selectType: '',\n\n            autoNumbering: true,\n\n            headerHeight: 35,\n            rowHeight: 27,\n            displayRowCount: 10,\n            minimumColumnWidth: 50,\n            notUseSmartRendering: false,\n            columnMerge: [],\n            scrollX: true,\n            scrollY: true,\n            useDataCopy: true,\n            useClientSort: true,\n            singleClickEdit: false,\n            toolbar: {\n                hasResizeHandler: true,\n                hasControlPanel: true,\n                hasPagination: true\n            }\n        };\n\n        this.options = $.extend(true, defaultOptions, options);\n    },\n\n    /**\n     * 내부 properties 를 초기화한다.\n     * @private\n     */\n    _initializeProperties: function() {\n        this.setOwnProperties({\n            'cellFactory': null,\n            'selectionModel': null,\n            'columnModel': null,\n            'dataModel': null,\n            'renderModel': null,\n            'layoutModel': null,\n            'focusModel': null,\n            'addOn': {},\n            'view': {\n                'lside': null,\n                'rside': null,\n                'toolbar': null,\n                'clipboard': null,\n                'layer': {\n                    ready: null,\n                    loading: null,\n                    empty: null\n                }\n            },\n            'timeoutIdForBlur': 0,\n            'timeoutIdForResize': 0,\n            'timeoutIdForSetRowList': 0,\n            '__$el': this.$el.clone()\n        });\n    },\n\n    /**\n     * 내부에서 사용할 모델 instance를 초기화한다.\n     *\n     * Initialize data model instances\n     * @private\n     */\n    _initializeModel: function() {\n        var offset = this.$el.offset();\n\n        this.columnModel = new ColumnModelData({\n            grid: this,\n            hasNumberColumn: this.option('autoNumbering'),\n            keyColumnName: this.option('keyColumnName'),\n            columnFixCount: this.option('columnFixCount'),\n            selectType: this.option('selectType')\n        });\n        this.setColumnModelList(this.option('columnModelList'));\n\n        this.dataModel = new RowListData([], {\n            grid: this,\n            useClientSort: this.option('useClientSort')\n        });\n        this.dataModel.reset([]);\n\n        this.dimensionModel = new DimensionModel({\n            grid: this,\n            offsetTop: offset.top,\n            offsetLeft: offset.left,\n            width: this.$el.width(),\n            headerHeight: this.option('headerHeight'),\n            rowHeight: this.option('rowHeight'),\n\n            scrollX: !!this.option('scrollX'),\n            scrollY: !!this.option('scrollY'),\n            scrollBarSize: this.scrollBarSize,\n\n            minimumColumnWidth: this.option('minimumColumnWidth'),\n            displayRowCount: this.option('displayRowCount')\n        });\n\n        this.focusModel = new FocusModel({\n            grid: this,\n            scrollX: !!this.option('scrollX'),\n            scrollY: !!this.option('scrollY'),\n            scrollBarSize: this.scrollBarSize\n        });\n\n        this.selectionModel = new SelectionModel({\n            grid: this\n        });\n\n        if (!this.option('useDataCopy')) {\n            this.selectionModel.disable();\n        }\n\n        if (this.option('notUseSmartRendering')) {\n            this.renderModel = new RenderModel({\n                grid: this\n            });\n        } else {\n            this.renderModel = new SmartRenderModel({\n                grid: this\n            });\n        }\n    },\n\n    /**\n     * 내부에서 사용할 view 인스턴스들을 초기화한다.\n     * @private\n     */\n    _initializeView: function() {\n        this.cellFactory = this.createView(CellFactory, {\n            grid: this\n        });\n\n        this.view.lside = this.createView(LsideFrame, {\n            grid: this\n        });\n\n        this.view.rside = this.createView(RsideFrame, {\n            grid: this\n        });\n\n        this.view.toolbar = this.createView(ToolbarLayout, {\n            grid: this\n        });\n\n        this.view.layer.ready = this.createView(ReadyLayer, {\n            grid: this\n        });\n\n        this.view.layer.empty = this.createView(EmptyLayer, {\n            grid: this\n        });\n\n        this.view.layer.loading = this.createView(LoadingLayer, {\n            grid: this\n        });\n\n        this.view.clipboard = this.createView(Clipboard, {\n            grid: this\n        });\n    },\n\n    /**\n     * 커스텀 이벤트 리스너를 초기화한다.\n     * @private\n     */\n    _initializeListener: function() {\n        this.listenTo(this.dimensionModel, 'change:bodyHeight', this._setHeight)\n            .listenTo(this.focusModel, 'select', this._onRowSelectChanged);\n    },\n\n    /**\n     * event 속성에 정의되지 않은 이벤트 attach 한다.\n     * @private\n     */\n    _attachExtraEvent: function() {\n        $(window).on('resize', $.proxy(this._onWindowResize, this));\n        $(document).on('focusin', $.proxy(this._onBlur, this));\n    },\n\n    /**\n     * 클립보드 blur 이벤트 핸들러\n     * @private\n     */\n    _onBlur: function() {\n        clearTimeout(this.timeoutIdForBlur);\n        this.timeoutIdForBlur = setTimeout($.proxy(this._doBlur, this), 0);\n    },\n\n    /**\n     * 실제 blur 를 한다.\n     * @private\n     */\n    _doBlur: function() {\n        var $focused, hasFocusedElement;\n\n        if (this.$el) {\n            $focused = this.$el.find(':focus');\n            hasFocusedElement = !!$focused.length;\n\n            if (!hasFocusedElement) {\n                this.focusModel.blur();\n            } else if ($focused.is('td') || $focused.is('a')) {\n                this.focusClipboard();\n            }\n        }\n    },\n\n    /**\n     * drag 이벤트 발생시 이벤트 핸들러\n     * @returns {boolean} false\n     * @private\n     */\n    _preventDrag: function() {\n        return false;\n    },\n\n    /**\n     * window resize  이벤트 핸들러\n     * @private\n     */\n    _onWindowResize: function() {\n        if (this.$el) {\n            this.dimensionModel.set('width', this.$el.width());\n        }\n    },\n\n    /**\n     * click 이벤트 핸들러\n     * @param {MouseEvent} mouseEvent 이벤트 객체\n     * @private\n     */\n    _onClick: function(mouseEvent) {\n        var eventData = this.createEventData(mouseEvent),\n            $target = $(mouseEvent.target),\n            cellInfo;\n\n        this.trigger('click', eventData);\n        if (eventData.isStopped()) {\n            return;\n        }\n        if (this._isCellElement($target, true)) {\n            cellInfo = this._getCellInfoFromElement($target.closest('td'));\n            if (this.option('singleClickEdit') &amp;&amp; !$target.is('input')) {\n                this.focusIn(cellInfo.rowKey, cellInfo.columnName);\n            }\n            this._triggerCellMouseEvent('clickCell', eventData, cellInfo);\n        }\n    },\n\n    /**\n     * doubleClick 이벤트 핸들러\n     * @param {MouseEvent} mouseEvent 이벤트 객체\n     * @private\n     */\n    _onDblClick: function(mouseEvent) {\n        var eventData = this.createEventData(mouseEvent),\n            $target = $(mouseEvent.target);\n\n        this.trigger('dblclick', eventData);\n        if (eventData.isStopped()) {\n            return;\n        }\n        if (this._isCellElement($target, true)) {\n            this._triggerCellMouseEvent('dblclickCell', eventData, $target.closest('td'));\n        }\n    },\n\n    /**\n     * mouseover 이벤트 발생시 실행될 핸들러\n     * @private\n     * @param {MouseEvent} mouseEvent 마우스 이벤트 객체\n     */\n    _onMouseOver: function(mouseEvent) {\n        var $target = $(mouseEvent.target),\n            eventData;\n\n        if (this._isCellElement($target)) {\n            eventData = this.createEventData(mouseEvent);\n            this._triggerCellMouseEvent('mouseoverCell', eventData, $target);\n        }\n    },\n\n    /**\n     * mouseout 이벤트 발생시 실행될 핸들러\n     * @private\n     * @param {MouseEvent} mouseEvent 마우스 이벤트 객체\n     */\n    _onMouseOut: function(mouseEvent) {\n        var $target = $(mouseEvent.target),\n            eventData;\n\n        if (this._isCellElement($target)) {\n            eventData = this.createEventData(mouseEvent);\n            this._triggerCellMouseEvent('mouseoutCell', eventData, $target);\n        }\n    },\n\n    /**\n     * 셀과 관련된 커스텀 마우스 이벤트를 발생시킨다.\n     * @private\n     * @param {string} eventName 이벤트명\n     * @param {MouseEvent} eventData 커스터마이징 된 마우스 이벤트 객체\n     * @param {(jQuery|object)} cell 이벤트가 발생한 cell (jquery 객체이거나 rowKey, columnName, rowData를 갖는 plain 객체)\n     */\n    _triggerCellMouseEvent: function(eventName, eventData, cell) {\n        var cellInfo = cell;\n        if (cell instanceof $) {\n            cellInfo = this._getCellInfoFromElement(cell);\n        }\n        _.extend(eventData, cellInfo);\n        this.trigger(eventName, eventData);\n    },\n\n    /**\n     * 해당 HTML요소가 셀인지 여부를 반환한다.\n     * @private\n     * @param {jQuery} $target 검사할 HTML요소의 jQuery 객체\n     * @param {boolean} isIncludeChild true이면 셀의 자식요소까지 포함한다.\n     * @return {boolean} 셀이면 true, 아니면 false\n     */\n    _isCellElement: function($target, isIncludeChild) {\n        var $td = isIncludeChild ? $target.closest('td') : $target;\n\n        if (!$td.is('td')) {\n            return false;\n        }\n        return !!($td.parent().attr('key') &amp;&amp; $td.attr('columnname'));\n    },\n\n    /**\n     * HTML요소에서 셀의 rowKey와 columnName값을 찾아서 rowData와 함께 객체로 반환한다.\n     * @private\n     * @param {jQuery} $cell TD요소의 jquery 객체\n     * @return {{rowKey: string, rowData: Data.Row, columnName: string}} 셀 관련 정보를 담은 객체\n     */\n    _getCellInfoFromElement: function($cell) {\n        var rowKey = $cell.parent().attr('key'),\n            columnName = $cell.attr('columnname');\n\n        return {\n            rowKey: rowKey,\n            columnName: columnName,\n            rowData: this.getRow(rowKey)\n        };\n    },\n\n    /**\n     * mousedown 이벤트 핸들러\n     * @param {event} mouseDownEvent 이벤트 객체\n     * @private\n     */\n    _onMouseDown: function(mouseDownEvent) {\n        var $target = $(mouseDownEvent.target),\n            eventData = this.createEventData(mouseDownEvent);\n\n        this.trigger('mousedown', eventData);\n        if (eventData.isStopped()) {\n            return;\n        }\n        if (!$target.is('input, a, button, select')) {\n            mouseDownEvent.preventDefault();\n            this.focusClipboard();\n        }\n    },\n\n    /**\n     * select 된 row 가 변경된 경우 이벤트 핸들러.\n     * radio select type 의 경우에 select 된 행을 check 해주는 로직을 담당한다.\n     * @param {(Number|String)} rowKey 변경이 일어난 데이터의 rowKey\n     * @private\n     */\n    _onRowSelectChanged: function(rowKey) {\n        if (this.columnModel.get('selectType') === 'radio') {\n            this.uncheckAll();\n            this.check(rowKey);\n        }\n        this.trigger('selectRow', {\n            rowKey: rowKey,\n            rowData: this.getRow(rowKey)\n        });\n    },\n\n    /**\n     * layout 에 필요한 크기 및 위치 데이터를 갱신한다.\n     * @private\n     */\n    updateLayoutData: function() {\n        var offset = this.$el.offset();\n\n        this.dimensionModel.set({\n            offsetTop: offset.top,\n            offsetLeft: offset.left,\n            width: this.$el.width(),\n            toolbarHeight: this.view.toolbar.$el.height()\n        });\n    },\n\n    /**\n     * option 값을 설정하거나 가져온다.\n     * @param {(String|Number)} key 데이터의 key\n     * @param {*} [value]   설정할 값. 두번째 값이 설정되어 있지 않다면 getter 로 활용된다.\n     * @return {*}  결과값\n     */\n    option: function(key, value) {\n        var result;\n\n        if (tui.util.isUndefined(value)) {\n            this.options = this.options || {};\n            result = this.options[key];\n        } else {\n            this.options[key] = value;\n            result = this;\n        }\n        return result;\n    },\n\n    /**\n     * Makes view ready to get keyboard input.\n     */\n    readyForKeyControl: function() {\n        this.focusClipboard();\n    },\n\n    /**\n     * clipboard 에 focus 한다.\n     */\n    focusClipboard: function() {\n        if (tui.util.isExisty(tui.util.pick(this, 'view', 'clipboard'))) {\n            this.view.clipboard.$el.focus();\n        }\n    },\n\n    /**\n     * 랜더링한다.\n     *\n     * Rendering grid view\n     */\n    render: function() {\n        var leftLine = $('&lt;div>').addClass('left_line'),\n            rightLine = $('&lt;div>').addClass('right_line');\n\n        this.$el.addClass('grid_wrapper')\n            .addClass('uio_grid')\n            .attr('instanceId', this.id)\n            .append(this.view.layer.empty.render().el)\n            .append(this.view.layer.loading.render().el)\n            .append(this.view.layer.ready.render().el);\n\n        this.view.layer.loading.show('초기화 중입니다.');\n\n        this.$el.append(this.view.lside.render().el)\n            .append(this.view.rside.render().el)\n            .append(this.view.toolbar.render().el)\n            .append(leftLine)\n            .append(rightLine)\n            .append(this.view.clipboard.render().el);\n        this._setHeight();\n        this.trigger('rendered');\n    },\n\n    /**\n     * rendering 이후, 또는 bodyHeight 가 변경되었을 때, header, toolbar 의 높이를 포함하여\n     * grid 의 전체 너비를 설정한다.\n     * @private\n     */\n    _setHeight: function() {\n        var bodyHeight = this.dimensionModel.get('bodyHeight'),\n            headerHeight = this.dimensionModel.get('headerHeight'),\n            toolbarHeight = this.view.toolbar.$el.height(),\n            height = toolbarHeight + headerHeight + bodyHeight;\n        this.$el.css('height', height + 'px');\n        this.dimensionModel.set({\n            toolbarHeight: toolbarHeight\n        });\n    },\n\n    /**\n     * rowKey 와 columnName 에 해당하는 값을 반환한다.\n     *\n     * @param {(Number|String)} rowKey    행 데이터의 고유 키\n     * @param {String} columnName   컬럼 이름\n     * @param {boolean} [isOriginal]  원본 데이터 리턴 여부\n     * @return {(Number|String)}    조회한 셀의 값.\n     */\n    getValue: function(rowKey, columnName, isOriginal) {\n        var value;\n        if (isOriginal) {\n            value = this.dataModel.getOriginal(rowKey, columnName);\n        } else {\n            value = this.dataModel.get(rowKey).get(columnName);\n        }\n        return value;\n    },\n\n    /**\n     * columnName에 해당하는 column data list를 리턴한다.\n     *\n     * @param {String} columnName   컬럼명\n     * @param {boolean} [isJsonString=false]  true 일 경우 JSON String 으로 반환한다.\n     * @return {Array} 컬럼명에 해당하는 셀들의 데이터 리스트\n     */\n    getColumnValues: function(columnName, isJsonString) {\n        var valueList = this.dataModel.pluck(columnName);\n        return isJsonString ? $.toJSON(valueList) : valueList;\n    },\n\n    /**\n     * rowKey에 해당하는 행의 데이터를 리턴한다. isJsonString을 true로 설정하면 결과를 json객체로 변환하여 리턴한다.\n     * @param {(Number|String)} rowKey  행 데이터의 고유 키\n     * @param {Boolean} [isJsonString=false]  true 일 경우 JSON String 으로 반환한다.\n     * @return {Object} 행 데이터\n     */\n    getRow: function(rowKey, isJsonString) {\n        var row = this.dataModel.get(rowKey);\n        row = row &amp;&amp; row.toJSON();\n        return isJsonString ? $.toJSON(row) : row;\n    },\n\n    /**\n     * 그리드 전체 데이터 중에서 index에 해당하는 순서의 데이터 객체를 리턴한다.\n     * @param {Number} index 행의 인덱스\n     * @param {Boolean} [isJsonString=false]  true 일 경우 JSON String 으로 반환한다.\n     * @return {Object} 행 데이터\n     */\n    getRowAt: function(index, isJsonString) {\n        var row = this.dataModel.at(index).toJSON();\n        row = isJsonString ? $.toJSON(row) : row;\n        return row;\n    },\n\n    /**\n     * 현재 그리드에 설정된 전체 데이터의 개수를 리턴한다.\n     * @return {Number} 데이터 개수\n     */\n    getRowCount: function() {\n        return this.dataModel.length;\n    },\n\n    /**\n     * rowKey 와 columnName 에 해당하는 td element 를 반환한다.\n     * 내부적으로 자동으로 mainRowKey 를 찾아 반환한다.\n     * @param {(Number|String)} rowKey    행 데이터의 고유 키\n     * @param {String} columnName   컬럼 이름\n     * @return {jQuery} 해당 jQuery Element\n     */\n    getElement: function(rowKey, columnName) {\n        var $frame = this.columnModel.isLside(columnName) ? this.view.lside.$el : this.view.rside.$el;\n        rowKey = this.dataModel.getMainRowKey(rowKey, columnName);\n        return $frame.find('tr[key=\"' + rowKey + '\"]').find('td[columnname=\"' + columnName + '\"]');\n    },\n\n    /**\n     * rowKey에 해당하는 행에 대해 선택한다.\n     * - checkRow()는 행에 포함된 체크박스나 라디오박스를 선택하며, selectRow()는 클릭된 행이 선택되어졌음을 시각적으로 나타내기 위해 해당 행의 배경색을 변경한다.\n     *\n     * @param {(Number|String)} rowKey 행 데이터의 고유 키\n     */\n    select: function(rowKey) {\n        this.focusModel.select(rowKey);\n    },\n\n    /**\n     * 선택되었던 행에 대한 선택을 해제한다.\n     */\n    unselect: function() {\n        this.focusModel.unselect(true);\n    },\n\n    /**\n     * 그리드 내에서 현재 선택된 row의 키값을 리턴한다.\n     * @return {(Number|String)} 행 데이터의 고유 키\n     */\n    getSelectedRowKey: function() {\n        return this.focusModel.which().rowKey;\n    },\n\n    /**\n     * Sets the vlaue of the cell identified by the specified rowKey and columnName.\n     * @param {(Number|String)} rowKey    행 데이터의 고유 키\n     * @param {String} columnName   컬럼 이름\n     * @param {(Number|String)} columnValue 할당될 값\n     * @param {Boolean} [silent=false] 이벤트 발생 여부. true 로 변경할 상황은 거의 없다.\n     * @returns {Boolean} True if affected row is exist\n     */\n    setValue: function(rowKey, columnName, columnValue, silent) {\n        var row = this.dataModel.get(rowKey),\n            obj = {},\n            result;\n\n        columnValue = _.isString(columnValue) ? $.trim(columnValue) : columnValue;\n        if (row) {\n            obj[columnName] = columnValue;\n            row.set(obj, {\n                silent: silent\n            });\n            result = true;\n        } else {\n            result = false;\n        }\n\n        return result;\n    },\n\n    /**\n     * columnName 에 해당하는 값을 전부 변경한다.\n     * @param {String} columnName 컬럼명\n     * @param {(Number|String)} columnValue 변경할 컬럼 값\n     * @param {Boolean} [isCheckCellState=true] 셀의 편집 가능 여부 와 disabled 상태를 체크할지 여부\n     * @param {Boolean} [silent=false] change 이벤트 trigger 할지 여부.\n     */\n    setColumnValues: function(columnName, columnValue, isCheckCellState, silent) {\n        var obj = {},\n            cellState = {\n                isDisabled: false,\n                isEditable: true\n            };\n\n        obj[columnName] = columnValue;\n        isCheckCellState = isCheckCellState === undefined ? true : isCheckCellState;\n\n        this.dataModel.forEach(function(row) {\n            if (isCheckCellState) {\n                cellState = this.getCellState(row.get('rowKey'), columnName);\n            }\n            if (!cellState.isDisabled &amp;&amp; cellState.isEditable) {\n                row.set(obj, {\n                    silent: silent\n                });\n            }\n        }, this);\n    },\n\n    /**\n     * rowList 를 설정한다. setRowList 와 다르게 setOriginalRowList 를 호출하여 원본데이터를 갱신하지 않는다.\n     * @param {Array} rowList 설정할 데이터 배열 값\n     * @param {boolean} [isParse=true]  backbone 의 parse 로직을 수행할지 여부\n     */\n    replaceRowList: function(rowList, isParse) {\n        var callback = tui.util.bind(function() {\n            this.dataModel.set(rowList, {\n                parse: isParse\n            });\n        }, this);\n        this.showGridLayer('loading');\n        isParse = isParse === undefined ? true : isParse;\n        //데이터 파싱에 시간이 많이 걸릴 수 있으므로, loading layer 를 먼저 보여주기 위해 timeout 을 사용한다.\n        if (rowList &amp;&amp; rowList.length > 500) {\n            clearTimeout(this.timeoutIdForSetRowList);\n            this.timeoutIdForSetRowList = setTimeout($.proxy(function() {\n                callback();\n            }, this), 0);\n        } else {\n            callback();\n        }\n    },\n\n    /**\n     * rowList 를 설정하고, setOriginalRowList 를 호출하여 원본데이터를 갱신한다.\n     * @param {Array} rowList 설정할 데이터 배열 값\n     * @param {boolean} [isParse=true]  backbone 의 parse 로직을 수행할지 여부\n     * @param {function} [callback] 완료시 호출될 함수\n     */\n    setRowList: function(rowList, isParse, callback) {\n        var doProcess = tui.util.bind(function() {\n            this.dataModel.reset(rowList, {\n                parse: isParse\n            });\n            this.dataModel.setOriginalRowList();\n            if (_.isFunction(callback)) {\n                callback();\n            }\n        }, this);\n        this.showGridLayer('loading');\n        isParse = isParse === undefined ? true : isParse;\n        //데이터 파싱에 시간이 많이 걸릴 수 있으므로, loading layer 를 먼저 보여주기 위해 timeout 을 사용한다.\n        if (rowList &amp;&amp; rowList.length > 500) {\n            clearTimeout(this.timeoutIdForSetRowList);\n            this.timeoutIdForSetRowList = setTimeout($.proxy(function() {\n                doProcess();\n            }, this), 0);\n        } else {\n            doProcess();\n        }\n    },\n\n    /**\n     * rowKey, columnName 에 해당하는 셀에 포커싱한다.\n     * @param {(Number|String)} rowKey    행 데이터의 고유 키\n     * @param {String} columnName   컬럼 이름\n     * @param {boolean} [isScrollable=false] 그리드에서 해당 영역으로 scroll 할지 여부\n     */\n    focus: function(rowKey, columnName, isScrollable) {\n        this.focusModel.focus(rowKey, columnName, isScrollable);\n    },\n\n    /**\n     * 셀을 편집모드로 전환한다.\n     * @param {(Number|String)} rowKey    행 데이터의 고유 키\n     * @param {String} columnName   컬럼 이름\n     * @param {boolean} [isScrollable=false] 그리드에서 해당 영역으로 scroll 할지 여부\n     */\n    focusIn: function(rowKey, columnName, isScrollable) {\n        var cellPainter;\n        this.focus(rowKey, columnName, isScrollable);\n        rowKey = this.dataModel.getMainRowKey(rowKey, columnName);\n        if (this.isEditable(rowKey, columnName)) {\n            cellPainter = this.cellFactory.getInstance(this.columnModel.getEditType(columnName));\n            cellPainter.focusIn(this.getElement(rowKey, columnName));\n        } else {\n            this.focusClipboard();\n        }\n    },\n\n    /**\n     * rowIndex, columnIndex 에 해당하는 컬럼에 포커싱한다.\n     * @param {(Number|String)} rowIndex 행 index\n     * @param {String} columnIndex 열 index\n     * @param {boolean} [isScrollable=false] 그리드에서 해당 영역으로 scroll 할지 여부\n     */\n    focusAt: function(rowIndex, columnIndex, isScrollable) {\n        var row = this.dataModel.at(rowIndex),\n            column = this.columnModel.at(columnIndex, true);\n        if (row &amp;&amp; column) {\n            this.focus(row.get('rowKey'), column['columnName'], isScrollable);\n        }\n    },\n\n    /**\n     * rowIndex, columnIndex 에 해당하는 컬럼에 포커싱 후 편진모드로 전환 한다.\n     * @param {(Number|String)} rowIndex 행 index\n     * @param {String} columnIndex 열 index\n     * @param {boolean} [isScrollable=false] 그리드에서 해당 영역으로 scroll 할지 여부\n     */\n    focusInAt: function(rowIndex, columnIndex, isScrollable) {\n        var row = this.dataModel.at(rowIndex),\n            column = this.columnModel.at(columnIndex, true);\n        if (row &amp;&amp; column) {\n            this.focusIn(row.get('rowKey'), column['columnName'], isScrollable);\n        }\n    },\n\n    /**\n     * 현재 포커스 된 컬럼이 있을 경우 포커스 상태를 해제한다\n     */\n    blur: function() {\n        this.focusModel.blur();\n    },\n\n    /**\n     * 전체 행을 선택한다.\n     */\n    checkAll: function() {\n        this.setColumnValues('_button', true);\n    },\n\n    /**\n     * rowKey에 해당하는 행의 체크박스 및 라디오박스를 선택한다.\n     * @param {(Number|String)} rowKey    행 데이터의 고유 키\n     */\n    check: function(rowKey) {\n        this.setValue(rowKey, '_button', true);\n    },\n\n    /**\n     * 모든 행을 선택 해제 한다.\n     */\n    uncheckAll: function() {\n        this.setColumnValues('_button', false);\n    },\n\n    /**\n     * rowKey 에 해당하는 행의 체크박스 및 라디오박스를 선택한다.\n     * @param {(Number|String)} rowKey    행 데이터의 고유 키\n     */\n    uncheck: function(rowKey) {\n        this.setValue(rowKey, '_button', false);\n    },\n\n    /**\n     * 그리드의 모든 데이터를 삭제하고 norowlayer 클래스명을 가지는 엘리먼트를 보여준다.\n     */\n    clear: function() {\n        //@todo: empty 레이어 추가\n        this.setRowList([]);\n    },\n\n    /**\n     * rowKey에 해당하는 그리드 데이터를 삭제한다.\n     * @param {(Number|String)} rowKey - 행 데이터의 고유 키\n     * @param {boolean|object} options - 삭제 옵션\n     * @param {boolean} options.removeOriginalData - 원본 데이터도 함께 삭제할 지 여부\n     * @param {boolean} options.keepRowSpanData - rowSpan이 mainRow를 삭제하는 경우 데이터를 유지할지 여부\n     */\n    removeRow: function(rowKey, options) {\n        this.dataModel.removeRow(rowKey, options);\n    },\n\n    /**\n     * chcked된 행을 삭제한다.\n     * @param {boolean} isConfirm 삭제하기 전에 confirm 메시지를 표시할지 여부\n     * @return {boolean} 삭제된 행이 있으면 true, 없으면 false\n     */\n    removeCheckedRows: function(isConfirm) {\n        var rowKeyList = this.getCheckedRowKeyList(),\n            message = rowKeyList.length + '건의 데이터를 삭제하시겠습니까?';\n\n        if (rowKeyList.length > 0 &amp;&amp; (!isConfirm || confirm(message))) {\n            _.each(rowKeyList, function(rowKey) {\n                this.removeRow(rowKey);\n            }, this);\n            return true;\n        }\n        return false;\n    },\n\n    /**\n     * rowKey에 해당하는 행을 활성화시킨다.\n     * @param {(Number|String)} rowKey 행 데이터의 고유 키\n     */\n    enableRow: function(rowKey) {\n        this.dataModel.get(rowKey).setRowState('');\n    },\n\n    /**\n     * rowKey에 해당하는 행을 비활성화 시킨다.\n     * @param {(Number|String)} rowKey    행 데이터의 고유 키\n     */\n    disableRow: function(rowKey) {\n        this.dataModel.get(rowKey).setRowState('DISABLED');\n    },\n\n    /**\n     * rowKey에 해당하는 행의 메인 체크박스를 체크할 수 있도록 활성화 시킨다.\n     * @param {(Number|String)} rowKey 행 데이터의 고유 키\n     */\n    enableCheck: function(rowKey) {\n        this.dataModel.get(rowKey).setRowState('');\n    },\n\n    /**\n     * rowKey에 해당하는 행의 메인 체크박스를 체크하지 못하도록 비활성화 시킨다.\n     * @param {(Number|String)} rowKey 행 데이터의 고유 키\n     */\n    disableCheck: function(rowKey) {\n        this.dataModel.get(rowKey).setRowState('DISABLED_CHECK');\n    },\n\n    /**\n     * 현재 선택된 행들의 키값만을 배열로 리턴한다.\n     * @param {Boolean} [isJsonString=false]  true 일 경우 json 문자열을 리턴한다.\n     * @return {Array|String} 선택된 행들의 키값 리스트.\n     */\n    getCheckedRowKeyList: function(isJsonString) {\n        var rowKeyList = [];\n        _.each(this.dataModel.where({\n            _button: true\n        }), function(row) {\n            rowKeyList.push(row.get('rowKey'));\n        }, this);\n        return isJsonString ? $.toJSON(rowKeyList) : rowKeyList;\n    },\n\n    /**\n     * 현재 선택된 행들의 모든 데이터를 배열로 리턴한다.\n     * @param {Boolean} [isJsonString=false]  true 일 경우 json 문자열을 리턴한다.\n     * @return {Array|String} 선택된 행들의 데이터값 리스트.\n     */\n    getCheckedRowList: function(isJsonString) {\n        var checkedRowList = this.dataModel.getRowList(true);\n        return isJsonString ? $.toJSON(checkedRowList) : checkedRowList;\n    },\n\n    /**\n     * 그리드에 설정된 컬럼모델 정보를 배열 형태로 리턴한다.\n     * @return {Array}  컬럼모델 리스트\n     */\n    getColumnModelList: function() {\n        return this.columnModel.get('dataColumnModelList');\n    },\n\n    /**\n     * 그리드 내에서 변경된 데이터들의 목록을 구성하여 리턴한다.\n     * 리턴되는 객체에는 createList, updateList, deleteList 라는 필드가 있고,\n     * 각 필드에는 변경된 데이터들이 배열로 구성되어 있다.\n     * @param {Object} [options] Options\n     *      @param {boolean} [options.isOnlyChecked=false] true 로 설정된 경우 checked 된 데이터 대상으로 비교 후 반환한다.\n     *      @param {boolean} [options.isRaw=false] true 로 설정된 경우 내부 연산용 데이터 제거 필터링을 거치지 않는다.\n     *      @param {boolean} [options.isOnlyRowKeyList=false] true 로 설정된 경우 키값만 저장하여 리턴한다.\n     *      @param {Array} [options.filteringColumnList]   행 데이터 중에서 데이터 변경으로 간주하지 않을 컬럼 이름을 배열로 설정한다.\n     * @return {{createList: Array, updateList: Array, deleteList: Array}} 옵션에 따라 반환된 수정된 데이터 목록\n     */\n    getModifiedRowList: function(options) {\n        //@todo 파라미터 옵션에 따른 데이터 형 변화\n        return this.dataModel.getModifiedRowList(options);\n    },\n\n    /**\n     * 현재 그리드의 제일 끝에 행을 추가한다.\n     * @param {object} [row] - row 데이터 오브젝트 없을경우 임의로 빈 데이터를 추가한다.\n     * @param {object} [options] - 옵션 객체\n     * @param {number} options.at - 데이터를 append 할 index\n     */\n    appendRow: function(row, options) {\n        this.dataModel.append(row, options);\n    },\n\n    /**\n     * 현재 그리드의 제일 앞에 행을 추가한다.\n     * @param {object} [row]  row 데이터 오브젝트 없을경우 임의로 빈 데이터를 추가한다.\n     */\n    prependRow: function(row) {\n        this.dataModel.prepend(row);\n    },\n\n    /**\n     * 열 고정 위치를 변경한다.\n     * @param {Number} columnFixCount 고정시킬 열의 인덱스\n     */\n    setColumnFixCount: function(columnFixCount) {\n        this.option({\n            columnFixCount: columnFixCount\n        });\n        this.columnModel.set({\n            columnFixCount: columnFixCount\n        });\n    },\n\n    /**\n     * 현재 그리드에 설정된 데이터의 변경 여부를 Boolean으로 리턴한다.\n     * - getModifiedRowList() 함수의 결과값을 이용하여 입력/수정/삭제가 되었으면 true를 리턴하고 그렇지 않은 경우에는 false를 리턴한다.\n     * @return {Boolean}    데이터가 변경되었는지 여부\n     */\n    isChanged: function() {\n        var modifiedRowMap = this.getModifiedRowList(),\n            result = false;\n\n        tui.util.forEach(modifiedRowMap, function(data) {\n            if (data.length) {\n                result = true;\n                return false;\n            }\n        });\n\n        return result;\n    },\n\n    /**\n     * setRowList()를 통해 그리드에 설정된 초기 데이터 상태로 복원한다.\n     * 그리드에서 수정되었던 내용을 초기화하는 용도로 사용한다.\n     */\n    restore: function() {\n        var originalRowList = this.dataModel.getOriginalRowList();\n        this.replaceRowList(originalRowList, true);\n    },\n\n    /**\n     * Grid Layer 를 모두 감춘다.\n     */\n    hideGridLayer: function() {\n        _.each(this.view.layer, function(view) {\n            view.hide();\n        }, this);\n    },\n\n    /**\n     * name 에 해당하는 Grid Layer를 보여준다.\n     * @param {String} name ready|empty|loading 중 하나를 설정한다.\n     */\n    showGridLayer: function(name) {\n        this.hideGridLayer();\n        if (this.view.layer[name]) {\n            this.view.layer[name].show();\n        }\n    },\n\n    /**\n     * pagination instance 를 반환한다.\n     * @return {instance} pagination 인스턴스\n     */\n    getPaginationInstance: function() {\n        var paginationView = this.view.toolbar.pagination;\n        if (paginationView) {\n            return paginationView.instance;\n        }\n    },\n\n    /**\n     * addon 을 활성화한다.\n     * @param {string} name addon 이름\n     * @param {object} options addon 에 넘길 파라미터\n     * @return {Core} this\n     */\n    use: function(name, options) {\n        var Constructor = addOn[name];\n\n        options = $.extend({grid: this}, options);\n        if (Constructor) {\n            this.addOn[name] = new Constructor(options);\n        }\n        return this;\n    },\n\n    /**\n     * 정렬이 되었는지 여부 반환\n     * @return {Boolean} 현재 정렬이 되어있는지 여부\n     */\n    isSorted: function() {\n        return this.dataModel.isSortedByField();\n    },\n\n    /**\n     * rowKey 와 columnName 에 해당하는 셀이 편집 가능한지 여부를 반환한다.\n     * @param {(Number|String)} rowKey 행 데이터의 고유 키\n     * @param {String} columnName 컬럼 이름\n     * @return {Boolean} 편집 가능한지 여부\n     */\n    isEditable: function(rowKey, columnName) {\n        var focused = this.focusModel.which(),\n            dataModel = this.dataModel,\n            row,\n            isEditable;\n\n        rowKey = rowKey !== undefined ? rowKey : focused.rowKey;\n        columnName = columnName !== undefined ? columnName : focused.columnName;\n        row = dataModel.get(rowKey);\n        isEditable = row ? row.isEditable(columnName) : true;\n        return isEditable;\n    },\n\n    /**\n     * rowKey 와 columnName 에 해당하는 셀이 disabled 상태인지 여부를 반환한다.\n     * @param {(Number|String)} rowKey 행 데이터의 고유 키\n     * @param {String} columnName 컬럼 이름\n     * @return {Boolean} disabled 상태인지 여부\n     */\n    isDisabled: function(rowKey, columnName) {\n        var focused = this.focusModel.which(),\n            dataModel = this.dataModel,\n            row,\n            isDisabled;\n\n        rowKey = rowKey !== undefined ? rowKey : focused.rowKey;\n        columnName = columnName !== undefined ? columnName : focused.columnName;\n        row = dataModel.get(rowKey);\n        isDisabled = row ? row.isDisabled(columnName) : false;\n        return isDisabled;\n    },\n\n    /**\n     * rowKey 와 columnName 에 해당하는 셀의 편집 가능여부와 disabled 상태 여부를 반환한다.\n     * @param {(Number|String)} rowKey 행 데이터의 고유 키\n     * @param {String} columnName 컬럼 이름\n     * @return {{isEditable: boolean, isDisabled: boolean}} 편집가능한지 여부와 disabled 인지 여부.\n     */\n    getCellState: function(rowKey, columnName) {\n        var focused = this.focusModel.which(),\n            dataModel = this.dataModel;\n\n        rowKey = rowKey !== undefined ? rowKey : focused.rowKey;\n        columnName = columnName !== undefined ? columnName : focused.columnName;\n\n        return dataModel.get(rowKey).getCellState(columnName);\n    },\n\n    /**\n     * columnModelList 를 재설정한다..\n     * @param {Array} columnModelList 컬럼모델 리스트\n     */\n    setColumnModelList: function(columnModelList) {\n        this.columnModel.set('columnModelList', columnModelList);\n    },\n\n    /**\n     * columnName 기준으로 정렬한다.\n     * @param {String} columnName 정렬할 컬럼명\n     * @param {Boolean} isAscending 오름차순 여부\n     */\n    sort: function(columnName, isAscending) {\n        this.dataModel.sortByField(columnName, isAscending);\n    },\n\n    /**\n     * 현재 그리드의 rowList 를 반환한다.\n     * @return {Array} 그리드의 데이터 리스트\n     */\n    getRowList: function() {\n        return this.dataModel.getRowList();\n    },\n\n    /**\n     * rowKey 와 columnName 에 해당하는 text 형태의 셀의 값을 삭제한다.\n     * @param {(Number|String)} rowKey 행 데이터의 고유 키\n     * @param {String} columnName 컬럼 이름\n     * @param {Boolean} [silent=false] 이벤트 발생 여부. true 로 변경할 상황은 거의 없다.\n     */\n    del: function(rowKey, columnName, silent) {\n        var editType = this.columnModel.getEditType(columnName),\n            mainRowKey = this.dataModel.getMainRowKey(rowKey, columnName),\n            isDisabledCheck = this.dataModel.get(mainRowKey).getRowState().isDisabledCheck,\n            deletableEditTypeList = ['text', 'text-convertible', 'text-password'],\n            isDeletable = $.inArray(editType, deletableEditTypeList) !== -1,\n            selectType = this.option('selectType'),\n            cellState = this.getCellState(mainRowKey, columnName),\n            isRemovable = !!(isDeletable &amp;&amp; cellState.isEditable &amp;&amp; !cellState.isDisabled);\n\n        if (isRemovable) {\n            this.setValue(mainRowKey, columnName, '', silent);\n            //silent 의 경우 데이터 모델의 change 이벤트가 발생하지 않기 때문에, 강제로 checkbox 를 세팅한다.\n            if (silent &amp;&amp; selectType === 'checkbox' &amp;&amp; !isDisabledCheck) {\n                this.setValue(mainRowKey, '_button', true, silent);\n            }\n        }\n    },\n\n    /**\n     * 2차원 배열로 된 데이터를 받아 현재 Focus된 셀을 기준으로 하여 각각의 인덱스의 해당하는 만큼 우측 아래 방향으로\n     * 이동하며 셀의 값을 변경한다. 완료한 후 적용된 셀 범위에 Selection을 지정한다.\n     * @param {Array[]} data - 2차원 배열 데이터. 내부배열의 사이즈는 모두 동일해야 한다.\n     */\n    paste: function(data) {\n        var columnModelList = this.columnModel.getVisibleColumnModelList(),\n            start = this._getStartIndexToPaste(),\n            end = this._getEndIndexToPaste(start, data, columnModelList);\n\n        _.each(data, function(row, index) {\n            this._setValueForPaste(row, start.rowIdx + index, start.columnIdx, end.columnIdx);\n        }, this);\n\n        this.selectionModel.start(start.rowIdx, start.columnIdx);\n        this.selectionModel.update(end.rowIdx, end.columnIdx);\n    },\n\n    /**\n     * 붙여넣기를 실행할때 시작점이 될 셀의 인덱스를 반환한다.\n     * @return {{rowIdx: number, columnIdx: number}} 행과 열의 인덱스 정보를 가진 객체\n     */\n    _getStartIndexToPaste: function() {\n        var startIdx;\n\n        if (this.selectionModel.hasSelection()) {\n            startIdx = this.selectionModel.getStartIndex();\n        } else {\n            startIdx = this.focusModel.indexOf();\n        }\n        return startIdx;\n    },\n\n    /**\n     * 붙여넣기를 실행할 때 끝점이 될 셀의 인덱스를 반환한다.\n     * @param  {{rowIdx: number, columnIdx: number}} startIdx - 시작점이 될 셀의 인덱스\n     * @param  {Array[]} data - 붙여넣기할 데이터\n     * @param  {Array} columnModelList - 현재 화면에 보여지는 컬럼모델의 목록\n     * @return {{rowIdx: number, columnIdx: number}} 행과 열의 인덱스 정보를 가진 객체\n     */\n    _getEndIndexToPaste: function(startIdx, data, columnModelList) {\n        var endIdx = {\n            rowIdx: data.length + startIdx.rowIdx - 1,\n            columnIdx: Math.min(data[0].length + startIdx.columnIdx, columnModelList.length) - 1\n        };\n        return endIdx;\n    },\n\n    /**\n     * 주어진 행 데이터를 지정된 인덱스의 컬럼에 반영한다.\n     * 셀이 수정 가능한 상태일 때만 값을 변경하며, RowSpan이 적용된 셀인 경우 MainRow인 경우에만 값을 변경한다.\n     * @param  {rowData} rowData - 붙여넣을 행 데이터\n     * @param  {number} rowIdx - 행 인덱스\n     * @param  {number} columnStartIdx - 열 시작 인덱스\n     * @param  {number} columnEndIdx - 열 종료 인덱스\n     */\n    _setValueForPaste: function(rowData, rowIdx, columnStartIdx, columnEndIdx) {\n        var row = this.dataModel.at(rowIdx),\n            attributes = {},\n            columnIdx, columnName, cellState, rowSpanData;\n\n        if (!row) {\n            row = this.dataModel.append({})[0];\n        }\n        for (columnIdx = columnStartIdx; columnIdx &lt;= columnEndIdx; columnIdx += 1) {\n            columnName = this.columnModel.at(columnIdx, true).columnName;\n            cellState = row.getCellState(columnName);\n            rowSpanData = row.getRowSpanData(columnName);\n\n            if (cellState.isEditable &amp;&amp; !cellState.isDisabled &amp;&amp; (!rowSpanData || rowSpanData.count >= 0)) {\n                attributes[columnName] = rowData[columnIdx - columnStartIdx];\n            }\n        }\n        row.set(attributes);\n    },\n\n    /**\n     * rowKey 와 columnName 에 해당하는 Cell 에 CSS className 을 설정한다.\n     * @param {(Number|String)} rowKey 행 데이터의 고유 rowKey\n     * @param {String} columnName 컬럼 이름\n     * @param {String} className 지정할 디자인 클래스명\n     */\n    addCellClassName: function(rowKey, columnName, className) {\n        this.dataModel.get(rowKey).addCellClassName(columnName, className);\n    },\n\n    /**\n     * rowKey 에 해당하는 행 전체에 CSS className 을 설정한다.\n     * @param {(Number|String)} rowKey 행 데이터의 고유 rowKey\n     * @param {String} className 지정할 디자인 클래스명\n     */\n    addRowClassName: function(rowKey, className) {\n        this.dataModel.get(rowKey).addClassName(className);\n    },\n\n    /**\n     * rowKey 와 columnName 에 해당하는 Cell 에 CSS className 을 제거한다.\n     * @param {(Number|String)} rowKey 행 데이터의 고유 rowKey\n     * @param {String} columnName 컬럼 이름\n     * @param {String} className 지정할 디자인 클래스명\n     */\n    removeCellClassName: function(rowKey, columnName, className) {\n        this.dataModel.get(rowKey).removeCellClassName(columnName, className);\n    },\n\n    /**\n     * rowKey 에 해당하는 행 전체에 CSS className 을 제거한다.\n     * @param {(Number|String)} rowKey 행 데이터의 고유 rowKey\n     * @param {String} className 지정할 디자인 클래스명\n     */\n    removeRowClassName: function(rowKey, className) {\n        this.dataModel.get(rowKey).removeClassName(className);\n    },\n\n    /**\n     * rowKey 와 columnName 에 해당하는 Cell 의 rowSpanData 를 반환한다.\n     * @param {(Number|String)} rowKey 행 데이터의 고유 rowKey\n     * @param {String} columnName 컬럼 이름\n     * @returns {object} rowSpanData\n     */\n    getRowSpanData: function(rowKey, columnName) {\n        var row = this.dataModel.get(rowKey);\n        if (row) {\n            return row.getRowSpanData(columnName);\n        }\n    },\n\n    /**\n     * rowKey에 해당하는 행의 인덱스를 반환한다.\n     * @param {number|string} rowKey - 행 고유키\n     * @return {number} - 인덱스\n     */\n    getIndexOfRow: function(rowKey) {\n        return this.dataModel.indexOfRowKey(rowKey);\n    },\n\n    /**\n     * 화면에 한번에 보여지는 행 개수를 변경한다.\n     * @param {number} count - 행 개수\n     */\n    setDisplayRowCount: function(count) {\n        this.dimensionModel.set('displayRowCount', count);\n    },\n\n    /**\n     * 데이터 필터링 기능 함수. 전체 그리드 데이터의 columnName에 해당하는 데이터와 columnValue를 비교하여 필터링 한 결과를 그리드에 출력한다\n     * @todo 기능 구현\n     * @param {String} columnName 컬럼 이름\n     * @param {(String|Number)} columnValue 컬럼 이름\n     */\n    filterData: function(columnName, columnValue) { // eslint-disable-line no-unused-vars\n    },\n\n    /**\n     * 그리드를 편집할 수 있도록 막았던 포커스를 풀고 딤드를 제거한다.\n     * @todo 기능 구현\n     */\n    enable: function() {\n    },\n\n    /**\n     * 그리드를 편집할 수 없도록 입력 엘리먼트들의 포커스를 막고, 옵션에 따라 딤드 처리한다.\n     * @todo 기능 구현\n     */\n    disable: function() {\n    },\n\n    /**\n     * Sets the width and height of the dimension.\n     * @param {(number|null)} width - Width\n     * @param {(number|null)} height - Height\n     */\n    setSize: function(width, height) {\n        if (width > 0) {\n            this.$el.width(width);\n        }\n        if (height > 0) {\n            this.dimensionModel.setHeight(height);\n        }\n        this.updateLayoutData();\n    },\n\n    /**\n     * 스크롤 핸들러의 위치를 변경한다.\n     * @todo 기능 구현\n     */\n    setScrollHandlerPosition: function() {},\n\n    /**\n     * 소멸자\n     */\n    destroy: function() {\n        this.stopListening();\n        this.destroyChildren();\n        _.each(this, function(value, property) {\n            if (property !== 'publicInstance') {\n                if (value instanceof View) {\n                    if (value &amp;&amp; tui.util.isFunction(value.destroy)) {\n                        value.destroy();\n                    }\n                }\n                if (property === 'view') {\n                    _.each(value, function(instance) {\n                        if (instance &amp;&amp; tui.util.isFunction(instance.destroy)) {\n                            instance.destroy();\n                        }\n                    }, this);\n                }\n            }\n\n            if (value &amp;&amp; tui.util.isFunction(value._destroy)) {\n                value._destroy();\n            }\n\n            if (value &amp;&amp; tui.util.isFunction(value.stopListening)) {\n                value.stopListening();\n            }\n\n            if (property !== '$el' &amp;&amp; property !== '__$el') {\n                this[property] = null;\n            }\n        }, this);\n        this.$el.replaceWith(this.__$el);\n        this.$el = this.__$el = null;\n    }\n});\n\nCore.prototype.__instance = Core.prototype.__instance || {};\n\nmodule.exports = Core;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"