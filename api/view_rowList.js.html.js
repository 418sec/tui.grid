ne.util.defineNamespace("fedoc.content", {});
fedoc.content["view_rowList.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview RowList View\n * @author NHN Ent. FE Development Team\n */\n'use strict';\n\nvar View = require('../base/view');\nvar RowPainter = require('./painter/row');\n\n/**\n * RowList View\n * @module view/rowList\n */\nvar RowList = View.extend(/**@lends module:view/rowList.prototype */{\n    /**\n     * 초기화 함수\n     * @constructs\n     * @extends module:baes/view\n     * @param {object} options 옵션 객체\n     *      @param {string} [options.whichSide='R']   어느 영역에 속하는 rowList 인지 여부. 'L|R' 중 하나를 지정한다.\n     */\n    initialize: function(options) {\n        var focusModel, renderModel, whichSide;\n\n        View.prototype.initialize.apply(this, arguments);\n\n        whichSide = (options &amp;&amp; options.whichSide) || 'R';\n        this.setOwnProperties({\n            whichSide: whichSide,\n            bodyTableView: options.bodyTableView,\n            columnModelList: this.grid.columnModel.getVisibleColumnModelList(whichSide, true),\n            collection: this.grid.renderModel.getCollection(whichSide),\n            sortOptions: null,\n            renderedRowKeys: null,\n            rowPainter: null\n        });\n        this._createRowPainter();\n        this._delegateTableEventsFromBody();\n        this._focusClipboardDebounced = _.debounce(this._focusClipboard, 10);\n\n        focusModel = this.grid.focusModel;\n        renderModel = this.grid.renderModel;\n        this.listenTo(this.collection, 'change', this._onModelChange)\n            .listenTo(focusModel, 'select', this._onSelect)\n            .listenTo(focusModel, 'unselect', this._onUnselect)\n            .listenTo(focusModel, 'focus', this._onFocus)\n            .listenTo(focusModel, 'blur', this._onBlur)\n            .listenTo(renderModel, 'rowListChanged', this.render);\n    },\n\n    /**\n     * Rendering 에 사용할 RowPainter Instance 를 생성한다.\n     * @private\n     */\n    _createRowPainter: function() {\n        this.rowPainter = new RowPainter({\n            grid: this.grid,\n            columnModelList: this.columnModelList\n        });\n    },\n\n    /**\n     * 기존에 생성되어 있던 TR요소들 중 새로 렌더링할 데이터와 중복되지 않은 목록의 TR요소만 삭제한다.\n     * @param {array} dupRowKeys 중복된 데이터의 rowKey 목록\n     */\n    _removeOldRows: function(dupRowKeys) {\n        var firstIdx = _.indexOf(this.renderedRowKeys, dupRowKeys[0]),\n            lastIdx = _.indexOf(this.renderedRowKeys, _.last(dupRowKeys)),\n            $rows = this.$el.children('tr');\n\n        $rows.slice(0, firstIdx).remove();\n        $rows.slice(lastIdx + 1).remove();\n    },\n\n    /**\n     * 기존의 렌더링된 데이터와 중복되지 않은 목록에 대해서만 TR요소를 추가한다.\n     * @param {array} rowKeys 렌더링할 데이터의 rowKey 목록\n     * @param {array} dupRowKeys 중복된 데이터의 rowKey 목록\n     */\n    _appendNewRows: function(rowKeys, dupRowKeys) {\n        var beforeRows = this.collection.slice(0, _.indexOf(rowKeys, dupRowKeys[0])),\n            afterRows = this.collection.slice(_.indexOf(rowKeys, _.last(dupRowKeys)) + 1);\n\n        this.$el.prepend(this._getRowsHtml(beforeRows));\n        this.$el.append(this._getRowsHtml(afterRows));\n    },\n\n    /**\n     * 전체 행목록을 갱신한다.\n     */\n    _resetRows: function() {\n        var html = this._getRowsHtml(this.collection.models),\n            $tbody;\n\n        if (RowList.isInnerHtmlOfTbodyReadOnly) {\n            $tbody = this.bodyTableView.redrawTable(html);\n            this.setElement($tbody, false); // table이 다시 생성되었기 때문에 tbody의 참조를 갱신해준다.\n\n            // IE7에서 레이아웃이 틀어지는 현상 방지\n            if (tui.util.browser.msie &amp;&amp; tui.util.browser.version &lt;= 7) {\n                $tbody.width($tbody.width());\n            }\n        } else {\n            // IE의 호환성 보기를 사용하면 브라우저 검출이 정확하지 않기 때문에, try/catch로 방어코드를 추가함.\n            try {\n                this.$el[0].innerHTML = html;\n            } catch (e) {\n                RowList.isInnerHtmlOfTbodyReadOnly = true;\n                this._resetRows();\n            }\n        }\n    },\n\n    /**\n     * 행데이터 목록을 받아, HTML 문자열을 생성해서 반환한다.\n     * @param {Model.Row[]} rows - 행데이터 목록\n     * @return {string} 생성된 HTML 문자열\n     */\n    _getRowsHtml: function(rows) {\n        return _.map(rows, this.rowPainter.getHtml, this.rowPainter).join('');\n    },\n\n    /**\n     * timeout을 사용해 일정 시간이 지난 후 포커스를 Clipboard로 옮긴다.\n     */\n    _focusClipboard: function() {\n        try {\n            this.grid.focusClipboard();\n        } catch (e) {\n            // prevent Error from running test cases (caused by setTimeout in _.debounce())\n        }\n    },\n\n    /**\n     * tr 엘리먼트를 찾아서 반환한다.\n     * @param {(string|number)} rowKey rowKey 대상의 키값\n     * @return {jquery} 조회한 tr jquery 엘리먼트\n     * @private\n     */\n    _getRowElement: function(rowKey) {\n        return this.$el.find('tr[key=\"' + rowKey + '\"]');\n    },\n\n    /**\n     * focusModel 의 select 이벤트 발생시 이벤트 핸들러\n     * @param {(Number|String)} rowKey 대상의 키값\n     * @private\n     */\n    _onSelect: function(rowKey) {\n        this._setCssSelect(rowKey, true);\n    },\n\n    /**\n     * focusModel 의 unselect 이벤트 발생시 이벤트 핸들러\n     * @param {(Number|String)} rowKey 대상의 키값\n     * @private\n     */\n    _onUnselect: function(rowKey) {\n        this._setCssSelect(rowKey, false);\n    },\n\n    /**\n     * 인자로 넘어온 rowKey 에 해당하는 행(각 TD)에 Select 디자인 클래스를 적용한다.\n     * @param {(Number|String)} rowKey 대상의 키값\n     * @param {Boolean} isSelected  css select 를 수행할지 unselect 를 수행할지 여부\n     * @private\n     */\n    _setCssSelect: function(rowKey, isSelected) {\n        var grid = this.grid,\n            columnModelList = this.columnModelList,\n            columnName,\n            $trCache = {},\n            $tr, $td,\n            mainRowKey;\n\n        _.each(columnModelList, function(columnModel) {\n            columnName = columnModel['columnName'];\n            mainRowKey = grid.dataModel.getMainRowKey(rowKey, columnName);\n\n            $trCache[mainRowKey] = $trCache[mainRowKey] || this._getRowElement(mainRowKey);\n            $tr = $trCache[mainRowKey];\n            $td = $tr.find('td[columnname=\"' + columnName + '\"]');\n            if ($td.length) {\n                $td.toggleClass('selected', isSelected);\n            }\n        }, this);\n    },\n\n    /**\n     * focusModel 의 blur 이벤트 발생시 해당 $td 를 찾고, focus 클래스를 제거한다.\n     * @param {(Number|String)} rowKey 대상의 키값\n     * @param {String} columnName 컬럼명\n     * @private\n     */\n    _onBlur: function(rowKey, columnName) {\n        var $td = this.grid.getElement(rowKey, columnName);\n        if ($td.length) {\n            $td.removeClass('focused');\n        }\n    },\n\n    /**\n     * focusModel 의 _onFocus 이벤트 발생시 해당 $td 를 찾고, focus 클래스를 추가한다.\n     * @param {(Number|String)} rowKey 대상의 키값\n     * @param {String} columnName 컬럼명\n     * @private\n     */\n    _onFocus: function(rowKey, columnName) {\n        var $td = this.grid.getElement(rowKey, columnName);\n        if ($td.length) {\n            $td.addClass('focused');\n        }\n    },\n\n    /**\n     * 랜더링한다.\n     * @param {boolean} isModelChanged - 모델이 변경된 경우(add, remove..) true, 아니면(스크롤 변경 등) false\n     * @return {View.RowList} this 객체\n     */\n    render: function(isModelChanged) {\n        var rowKeys = this.collection.pluck('rowKey'),\n            dupRowKeys;\n\n        this.bodyTableView.resetTablePosition();\n\n        if (isModelChanged) {\n            this._resetRows();\n        } else {\n            dupRowKeys = _.intersection(rowKeys, this.renderedRowKeys);\n            if (_.isEmpty(rowKeys) || _.isEmpty(dupRowKeys) ||\n                // 중복된 데이터가 70% 미만일 경우에는 성능을 위해 innerHTML을 사용.\n                (dupRowKeys.length / rowKeys.length &lt; 0.7)) {\n                this._resetRows();\n            } else {\n                this._removeOldRows(dupRowKeys);\n                this._appendNewRows(rowKeys, dupRowKeys);\n            }\n        }\n\n        this.renderedRowKeys = rowKeys;\n        this._focusClipboardDebounced();\n        this._showLayer();\n\n        return this;\n    },\n\n    /**\n     * 테이블 내부(TR,TD)에서 발생하는 이벤트를 View.Layout.Body에게 넘겨 해당 요소들에게 위임하도록 설정한다.\n     * @private\n     */\n    _delegateTableEventsFromBody: function() {\n        this.bodyTableView.attachTableEventHandler('tr', this.rowPainter.getEventHandlerInfo());\n\n        _.each(this.rowPainter.getCellPainters(), function(painter, editType) {\n            var selector = 'td[edit-type=' + editType + ']',\n                handlerInfo = painter.getEventHandlerInfo();\n\n            this.bodyTableView.attachTableEventHandler(selector, handlerInfo);\n        }, this);\n    },\n\n    /**\n     * modelChange 이벤트 발생시 실행되는 핸들러 함수.\n     * @param {Model.Row} model Row 모델 객체\n     * @private\n     */\n    _onModelChange: function(model) {\n        var $tr = this._getRowElement(model.get('rowKey'));\n        this.rowPainter.onModelChange(model, $tr);\n    },\n\n    /**\n     * 데이터가 있다면 Layer 를 노출하고, 없는 경우 데이터 없음 레이어를 노출한다.\n     * @private\n     */\n    _showLayer: function() {\n        if (this.grid.dataModel.length) {\n            this.grid.hideGridLayer();\n        } else {\n            this.grid.showGridLayer('empty');\n        }\n    }\n},\n{\n    /**\n     * tbody 요소의 innerHTML이 읽기전용인지 여부\n     * @memberof RowList\n     * @static\n     */\n    isInnerHtmlOfTbodyReadOnly: (tui.util.browser.msie &amp;&amp; tui.util.browser.version &lt;= 9)\n});\n\nmodule.exports = RowList;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"