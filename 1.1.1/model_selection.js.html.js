tui.util.defineNamespace("fedoc.content", {});
fedoc.content["model_selection.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Selection Model class\n * @author NHN Ent. FE Development Team\n */\n'use strict';\n\nvar Model = require('../base/model'),\n    util = require('../common/util');\n\n/**\n * @ignore\n * @const\n * @type {{cell: string, row: string, column: string}}\n * @desc\n *  Selection states\n */\nvar SELECTION_STATE = {\n    cell: 'cell',\n    row: 'row',\n    column: 'column'\n};\n/**\n *  Selection Model class\n *  @module model/selection\n */\nvar Selection = Model.extend(/**@lends module:model/selection.prototype */{\n    /**\n     * @constructs\n     * @extends module:base/view\n     */\n    initialize: function(attr, options) {\n        Model.prototype.initialize.apply(this, arguments);\n\n        this.setOwnProperties({\n            dataModel: options.dataModel,\n            columnModel: options.columnModel,\n            dimensionModel: options.dimensionModel,\n            focusModel: options.focusModel,\n            renderModel: options.renderModel,\n\n            inputRange: null,\n            intervalIdForAutoScroll: null,\n            scrollPixelScale: 40,\n            _isEnabled: true,\n            _selectionState: SELECTION_STATE.cell\n        });\n\n        this.listenTo(this.dataModel, 'add remove sort reset', this.end);\n        this.listenTo(this.dataModel, 'paste', this._onPasteData);\n    },\n\n    defaults: {\n        /**\n         * Selection range\n         * ex) {row: [0, 1], column: [1, 2]}\n         * @type {{row: array, column: array}}\n         */\n        range: null\n    },\n\n    /**\n     * Event handler for 'paste' event on DataModel\n     * @param {Object} range - Range\n     */\n    _onPasteData: function(range) {\n        this.start(range.startIdx.row, range.startIdx.column);\n        this.update(range.endIdx.row, range.endIdx.column);\n    },\n\n    /**\n     * Set selection state\n     * @param {string} state - Selection state (cell, row, column)\n     */\n    setState: function(state) {\n        this._selectionState = SELECTION_STATE[state] || this._selectionState;\n    },\n\n    /**\n     * Return the selection state\n     * @returns {string} state - Selection state (cell, row, column)\n     */\n    getState: function() {\n        return this._selectionState;\n    },\n\n    /**\n     * Enables the selection.\n     */\n    enable: function() {\n        this._isEnabled = true;\n    },\n\n    /**\n     * Disables the selection.\n     */\n    disable: function() {\n        this.end();\n        this._isEnabled = false;\n    },\n\n    /**\n     * Returns whether the selection is enabled.\n     * @return {boolean} True if the selection is enabled.\n     */\n    isEnabled: function() {\n        return this._isEnabled;\n    },\n\n    /**\n     * Starts the selection.\n     * @param {Number} rowIndex - Row index\n     * @param {Number} columnIndex - Column index\n     * @param {string} state - Selection state강지\n     */\n    start: function(rowIndex, columnIndex, state) {\n        if (!this._isEnabled) {\n            return;\n        }\n        this.setState(state);\n        this.inputRange = {\n            row: [rowIndex, rowIndex],\n            column: [columnIndex, columnIndex]\n        };\n        this._resetRangeAttribute();\n    },\n\n    /**\n     * Starts the selection by mouse position.\n     * @param {number} pageX - X position relative to the document\n     * @param {number} pageY - Y position relative to the document\n     * @param {string} state - Selection state\n     */\n    startByMousePosition: function(pageX, pageY, state) {\n        var index = this.dimensionModel.getIndexFromMousePosition(pageX, pageY);\n        this.start(index.row, index.column, state);\n    },\n\n    /**\n     * Updates the selection range.\n     * @param {number} rowIndex - Row index\n     * @param {number} columnIndex - Column index\n     * @param {string} [state] - Selection state\n     */\n    update: function(rowIndex, columnIndex, state) {\n        var focusedIndex;\n\n        if (!this._isEnabled || rowIndex &lt; 0 || columnIndex &lt; 0) {\n            return;\n        }\n\n        if (!this.hasSelection()) {\n            focusedIndex = this.focusModel.indexOf();\n            this.start(focusedIndex.row, focusedIndex.column, state);\n        } else {\n            this.setState(state);\n        }\n\n        this._updateInputRange(rowIndex, columnIndex);\n        this._resetRangeAttribute();\n    },\n\n    /**\n     * Update input range (end range, not start range)\n     * @param {number} rowIndex - Row index\n     * @param {number} columnIndex - Column index\n     * @private\n     */\n    _updateInputRange: function(rowIndex, columnIndex) {\n        var inputRange = this.inputRange;\n\n        inputRange.row[1] = rowIndex;\n        inputRange.column[1] = columnIndex;\n    },\n\n    /**\n     * Extend column selection\n     * @param {undefined|Array} columnIndexes - Column indexes\n     * @param {number} pageX - Mouse position X\n     * @param {number} pageY - Mouse positino Y\n     */\n    extendColumnSelection: function(columnIndexes, pageX, pageY) {\n        var minimumColumnRange = this._minimumColumnRange,\n            index = this.dimensionModel.getIndexFromMousePosition(pageX, pageY),\n            range = {\n                row: [0, 0],\n                column: []\n            },\n            minMax;\n\n        if (!columnIndexes || !columnIndexes.length) {\n            columnIndexes = [index.column]\n        }\n\n        this._setScrolling(pageX, pageY);\n        if (minimumColumnRange) {\n            minMax = util.getMinMax(columnIndexes.concat(minimumColumnRange));\n        } else {\n            columnIndexes.push(this.inputRange.column[0]);\n            minMax = util.getMinMax(columnIndexes);\n        }\n        range.column.push(minMax.min, minMax.max);\n        this._resetRangeAttribute(range);\n    },\n\n    /**\n     * Set auto scrolling for selection\n     * @param {number} pageX - Mouse position X\n     * @param {number} pageY - Mouse positino Y\n     * @private\n     */\n    _setScrolling: function(pageX, pageY) {\n        var overflow = this.dimensionModel.getOverflowFromMousePosition(pageX, pageY);\n\n        this.stopAutoScroll();\n        if (this._isAutoScrollable(overflow.x, overflow.y)) {\n            this.intervalIdForAutoScroll = setInterval(\n                _.bind(this._adjustScroll, this, overflow.x, overflow.y)\n            );\n        }\n    },\n\n    /**\n     * Updates the selection range by mouse position.\n     * @param {number} pageX - X position relative to the document\n     * @param {number} pageY - Y position relative to the document\n     * @param {string} [state] - Selection state\n     */\n    updateByMousePosition: function(pageX, pageY, state) {\n        var index = this.dimensionModel.getIndexFromMousePosition(pageX, pageY);\n\n        this._setScrolling(pageX, pageY);\n        this.update(index.row, index.column, state);\n    },\n\n    /**\n     * selection 영역 선택을 종료하고 selection 데이터를 초기화한다.\n     */\n    end: function() {\n        this.inputRange = null;\n        this.unset('range');\n        this.unsetMinimumColumnRange();\n    },\n\n    /**\n     * Stops the auto-scroll interval.\n     */\n    stopAutoScroll: function() {\n        if (!_.isNull(this.intervalIdForAutoScroll)) {\n            clearInterval(this.intervalIdForAutoScroll);\n            this.intervalIdForAutoScroll = null;\n        }\n    },\n\n    /**\n     * Select all data in a row\n     */\n    selectRow: function(rowIndex) {\n        if (this._isEnabled) {\n            this.focusModel.focusAt(rowIndex, 0);\n            this.start(rowIndex, 0, SELECTION_STATE.row);\n            this.update(rowIndex, this.columnModel.getVisibleColumnModelList().length - 1);\n        }\n    },\n\n    /**\n     * Select all data in a column\n     */\n    selectColumn: function(columnIdx) {\n        if (this._isEnabled) {\n            this.focusModel.focusAt(0, columnIdx);\n            this.start(0, columnIdx, SELECTION_STATE.column);\n            this.update(this.dataModel.length - 1, columnIdx);\n        }\n    },\n\n    /**\n     * Selects all data range.\n     */\n    selectAll: function() {\n        if (this._isEnabled) {\n            this.start(0, 0, SELECTION_STATE.cell);\n            this.update(this.dataModel.length - 1, this.columnModel.getVisibleColumnModelList().length - 1);\n        }\n    },\n\n    /**\n     * Returns the row and column indexes of the starting position.\n     * @return {{row: number, column: number}} Objects containing indexes\n     */\n    getStartIndex: function() {\n        var range = this.get('range');\n        return {\n            row: range.row[0],\n            column: range.column[0]\n        };\n    },\n\n    /**\n     * Returns the row and column indexes of the ending position.\n     * @return {{row: number, column: number}} Objects containing indexes\n     */\n    getEndIndex: function() {\n        var range = this.get('range');\n        return {\n            row: range.row[1],\n            column: range.column[1]\n        };\n    },\n\n    /**\n     * selection 데이터가 존재하는지 확인한다.\n     * @return {boolean} selection 데이터 존재여부\n     */\n    hasSelection: function() {\n        return !!this.get('range');\n    },\n\n    /**\n     * Returns the string value of all cells in the selection range as a single string.\n     * @return {String} string of values\n     */\n    getValuesToString: function() {\n        var range = this.get('range'),\n            columnModelList, rowList, columnNameList, rowValues;\n\n        columnModelList = this.columnModel.getVisibleColumnModelList().slice(range.column[0], range.column[1] + 1);\n        rowList = this.dataModel.slice(range.row[0], range.row[1] + 1);\n\n        columnNameList = _.pluck(columnModelList, 'columnName');\n        rowValues = _.map(rowList, function(row) {\n            var tmpString = _.map(columnNameList, function(columnName) {\n                return row.getVisibleText(columnName);\n            });\n            return tmpString.join('\\t');\n        });\n\n        return rowValues.join('\\n');\n    },\n\n    /**\n     * 마우스 드래그로 selection 선택 시 auto scroll 조건에 해당하는지 반환한다.\n     * @param {Number} overflowX    가로축 기준 영역 overflow 값\n     * @param {Number} overflowY    세로축 기준 영역 overflow 값\n     * @return {boolean} overflow 되었는지 여부\n     * @private\n     */\n    _isAutoScrollable: function(overflowX, overflowY) {\n        return !(overflowX === 0 &amp;&amp; overflowY === 0);\n    },\n\n    /**\n     * Adjusts scrollTop and scrollLeft value.\n     * @param {Number} overflowX    가로축 기준 영역 overflow 값\n     * @param {Number} overflowY    세로축 기준 영역 overflow 값\n     * @private\n     */\n    _adjustScroll: function(overflowX, overflowY) {\n        var renderModel = this.renderModel;\n\n        if (overflowX) {\n            this._adjustScrollLeft(overflowX, renderModel.get('scrollLeft'), renderModel.get('maxScrollLeft'));\n        }\n        if (overflowY) {\n            this._adjustScrollTop(overflowY, renderModel.get('scrollTop'), renderModel.get('maxScrollTop'));\n        }\n    },\n\n    /**\n     * Adjusts scrollLeft value.\n     * @param  {number} overflowX - 1 | 0 | -1\n     * @param  {number} scrollLeft - Current scrollLeft value\n     * @param  {number} maxScrollLeft - Max scrollLeft value\n     * @private\n     */\n    _adjustScrollLeft: function(overflowX, scrollLeft, maxScrollLeft) {\n        var adjusted = scrollLeft,\n            pixelScale = this.scrollPixelScale;\n\n        if (overflowX &lt; 0) {\n            adjusted = Math.max(0, scrollLeft - pixelScale);\n        } else if (overflowX > 0) {\n            adjusted = Math.min(maxScrollLeft, scrollLeft + pixelScale);\n        }\n        this.renderModel.set('scrollLeft', adjusted);\n    },\n\n    /**\n     * Adjusts scrollTop value.\n     * @param  {number} overflowY - 1 | 0 | -1\n     * @param  {number} scrollTop - Current scrollTop value\n     * @param  {number} maxScrollTop - Max scrollTop value\n     * @private\n     */\n    _adjustScrollTop: function(overflowY, scrollTop, maxScrollTop) {\n        var adjusted = scrollTop,\n            pixelScale = this.scrollPixelScale;\n\n        if (overflowY &lt; 0) {\n            adjusted = Math.max(0, scrollTop - pixelScale);\n        } else if (overflowY > 0) {\n            adjusted = Math.min(maxScrollTop, scrollTop + pixelScale);\n        }\n        this.renderModel.set('scrollTop', adjusted);\n    },\n\n    /**\n     * Expands the 'this.inputRange' if rowspan data exists, and resets the 'range' attributes to the value.\n     * @param {{column: number[], row: number[]}} [inputRange = this.inputRange] - Input range\n     * @private\n     */\n    _resetRangeAttribute: function(inputRange) {\n        var dataModel = this.dataModel,\n            hasSpannedRange, spannedRange, tmpRowRange;\n\n        inputRange = inputRange || this.inputRange;\n        if (!inputRange) {\n            this.set('range', null);\n            return;\n        }\n\n        spannedRange = {\n            row: _.sortBy(inputRange.row),\n            column: _.sortBy(inputRange.column)\n        };\n\n        if (dataModel.isRowSpanEnable()) {\n            do {\n                tmpRowRange = _.assign([], spannedRange.row);\n                spannedRange = this._getRowSpannedIndex(spannedRange);\n\n                hasSpannedRange = (\n                    spannedRange.row[0] !== tmpRowRange[0] ||\n                    spannedRange.row[1] !== tmpRowRange[1]\n                );\n            } while (hasSpannedRange);\n        }\n\n        this._setRangeMinMax(spannedRange.row, spannedRange.column);\n        switch (this._selectionState) {\n            case SELECTION_STATE.column:\n                spannedRange.row = [0, dataModel.length - 1];\n                break;\n            case SELECTION_STATE.row:\n                spannedRange.column = [0, this.columnModel.getVisibleColumnModelList().length - 1];\n                break;\n            case SELECTION_STATE.cell:\n            default:\n                break;\n        }\n\n        this.set('range', spannedRange);\n    },\n\n    /**\n     * Set minimum column range\n     * @param {Array} range - Minimum column range\n     */\n    setMinimumColumnRange: function(range) {\n        this._minimumColumnRange = _.extend(range);\n    },\n\n    /**\n     * Unset minimum column range\n     */\n    unsetMinimumColumnRange: function() {\n        this._minimumColumnRange = null;\n    },\n\n    /**\n     * Set min, max value of range(row, column)\n     * @param {Array} rowRange - Row range\n     * @param {Array} columnRange - Column range\n     * @private\n     */\n    _setRangeMinMax: function(rowRange, columnRange) {\n        if (rowRange) {\n            rowRange[0] = Math.max(0, rowRange[0]);\n            rowRange[1] = Math.min(this.dataModel.length - 1, rowRange[1]);\n        }\n\n        if (columnRange) {\n            columnRange[0] = Math.max(0, columnRange[0]);\n            columnRange[1] = Math.min(this.columnModel.getVisibleColumnModelList().length - 1, columnRange[1]);\n        }\n    },\n\n    /**\n     * row start index 기준으로 rowspan 을 확인하며 startRangeList 업데이트 하는 함수\n     * @param {object} param - parameters\n     * @private\n     */\n    _concatRowSpanIndexFromStart: function(param) {\n        var startIndex = param.startIndex,\n            endIndex = param.endIndex,\n            columnName = param.columnName,\n            rowSpanData = param.startRowSpanDataMap &amp;&amp; param.startRowSpanDataMap[columnName],\n            startIndexList = param.startIndexList,\n            endIndexList = param.endIndexList,\n            spannedIndex;\n\n        if (!rowSpanData) {\n            return;\n        }\n\n        if (!rowSpanData['isMainRow']) {\n            spannedIndex = startIndex + rowSpanData['count'];\n            startIndexList.push(spannedIndex);\n        } else {\n            spannedIndex = startIndex + rowSpanData['count'] - 1;\n            if (spannedIndex > endIndex) {\n                endIndexList.push(spannedIndex);\n            }\n        }\n    },\n\n    /**\n     * row end index 기준으로 rowspan 을 확인하며 endRangeList 를 업데이트 하는 함수\n     * @param {object} param - parameters\n     * @private\n     */\n    _concatRowSpanIndexFromEnd: function(param) {\n        var endIndex = param.endIndex,\n            columnName = param.columnName,\n            rowSpanData = param.endRowSpanDataMap &amp;&amp; param.endRowSpanDataMap[columnName],\n            endIndexList = param.endIndexList,\n            dataModel = param.dataModel,\n            spannedIndex, tmpRowSpanData;\n\n        if (!rowSpanData) {\n            return;\n        }\n\n        if (!rowSpanData['isMainRow']) {\n            spannedIndex = endIndex + rowSpanData['count'];\n            tmpRowSpanData = dataModel.at(spannedIndex).getRowSpanData(columnName);\n            spannedIndex += tmpRowSpanData['count'] - 1;\n            if (spannedIndex > endIndex) {\n                endIndexList.push(spannedIndex);\n            }\n        } else {\n            spannedIndex = endIndex + rowSpanData['count'] - 1;\n            endIndexList.push(spannedIndex);\n        }\n    },\n\n    /**\n     * rowSpan 된 Index range 를 반환한다.\n     * @param {{row: Array, column: Array}} spannedRange 인덱스 정보\n     * @returns {{row: Array, column: Array}} New Range\n     * @private\n     */\n    _getRowSpannedIndex: function(spannedRange) {\n        var columnModelList = this.columnModel.getVisibleColumnModelList()\n                .slice(spannedRange.column[0], spannedRange.column[1] + 1),\n            dataModel = this.dataModel,\n            startIndexList = [spannedRange.row[0]],\n            endIndexList = [spannedRange.row[1]],\n            startRow = dataModel.at(spannedRange.row[0]),\n            endRow = dataModel.at(spannedRange.row[1]),\n            newSpannedRange = $.extend({}, spannedRange),\n            startRowSpanDataMap, endRowSpanDataMap, columnName, param;\n\n        if (!startRow || !endRow) {\n            return newSpannedRange;\n        }\n\n        startRowSpanDataMap = dataModel.at(spannedRange.row[0]).getRowSpanData();\n        endRowSpanDataMap = dataModel.at(spannedRange.row[1]).getRowSpanData();\n\n        //모든 열을 순회하며 각 열마다 설정된 rowSpan 정보에 따라 인덱스를 업데이트 한다.\n        _.each(columnModelList, function(columnModel) {\n            columnName = columnModel['columnName'];\n            param = {\n                columnName: columnName,\n                startIndex: spannedRange.row[0],\n                endIndex: spannedRange.row[1],\n                endRowSpanDataMap: endRowSpanDataMap,\n                startRowSpanDataMap: startRowSpanDataMap,\n                startIndexList: startIndexList,\n                endIndexList: endIndexList,\n                dataModel: dataModel\n            };\n            this._concatRowSpanIndexFromStart(param);\n            this._concatRowSpanIndexFromEnd(param);\n        }, this);\n\n        newSpannedRange.row = [Math.min.apply(null, startIndexList), Math.max.apply(null, endIndexList)];\n        return newSpannedRange;\n    }\n});\n\nmodule.exports = Selection;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"