tui.util.defineNamespace("fedoc.content", {});
fedoc.content["painter_cell.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview CellPainter 의 기초 클래스\n * @author NHN Ent. FE Development Team\n */\n'use strict';\n\nvar Painter = require('../base/painter');\nvar util = require('../common/util');\nvar keyNameMap = require('../common/constMap').keyName;\n\n/**\n * Cell Painter Base\n * @module painter/cell\n */\nvar Cell = tui.util.defineClass(Painter, /**@lends module:painter/cell.prototype */{\n    /**\n     * @constructs\n     * @extends module:base/painter\n     */\n    init: function() {\n        Painter.apply(this, arguments);\n        this.setOwnProperties({\n            _keyDownSwitch: $.extend({}, this._defaultKeyDownSwitch)\n        });\n    },\n\n    /**\n     * model 의 변화가 발생했을 때, td 를 다시 rendering 해야하는 대상 프로퍼티 목록. 필요에 따라 확장 시 재정의 한다.\n     */\n    redrawAttributes: ['isEditable', 'optionList', 'value'],\n\n    /*\n     * Markup template\n     * If use '&lt;%=class%>' key word, an error occurs.\n     * So use '&lt;%=className%>' instead of '&lt;%=class%>'\n     * @return {string} template\n     */\n    template: _.template(\n        '&lt;td' +\n        ' columnname=\"&lt;%=columnName%>\"' +\n        ' class=\"&lt;%=className%>\"' +\n        ' edit-type=\"&lt;%=editType%>\"' +\n        ' &lt;% if(rowSpan) print(\"rowSpan=\" + rowSpan )%>' +\n        '&lt;%=attributeString%>' +\n        '>' +\n        '&lt;%=contentHtml%>' +\n        '&lt;/td>'\n    ),\n\n    /**\n     * keyDownEvent 발생시 기본 동작 switch\n     * @private\n     */\n    _defaultKeyDownSwitch: {\n        'ESC': function(keyDownEvent, param) {\n            this.focusOut(param.$target);\n        },\n        'ENTER': function(keyDownEvent, param) {\n            this.focusOut(param.$target);\n        },\n        'TAB': function(keyDownEvent, param) {\n            if (keyDownEvent.shiftKey) {\n                this.grid.focusModel.focusIn(param.rowKey, param.focusModel.prevColumnName(), true);\n            } else {\n                this.grid.focusModel.focusIn(param.rowKey, param.focusModel.nextColumnName(), true);\n            }\n        },\n        'defaultAction': function() {}\n    },\n\n    /**\n     * Event handlers\n     */\n    eventHandler: {},\n\n    /**\n     * RowPainter 에서 Render model 변경 감지 시 RowPainter 에서 호출하는 onChange 핸들러\n     * @param {object} cellData Model 의 셀 데이터\n     * @param {jQuery} $tr  tr 에 해당하는 jquery 로 감싼 html 엘리먼트\n     */\n    onModelChange: function(cellData, $tr) {\n        var $td = $tr.find('td[columnname=\"' + cellData.columnName + '\"]'),\n            isRedraw = false,\n            hasFocusedElement;\n\n        tui.util.forEachArray(this.redrawAttributes, function(attribute) {\n            if ($.inArray(attribute, cellData.changed) !== -1) {\n                isRedraw = true;\n                return false;\n            }\n        }, this);\n\n        $td.attr('class', this._getClassNameList(cellData).join(' '));\n        try {\n            /*\n             * IE 7, 8 에서 $td.find(':focus') 호출시 unexpected error 발생하는 경우가 발생하여 try/catch 함.\n             */\n            hasFocusedElement = !!($td.find(':focus').length);\n        } catch (e) {\n            hasFocusedElement = false;\n        }\n\n        if (isRedraw) {\n            this.redraw(cellData, $td, hasFocusedElement);\n            if (hasFocusedElement) {\n                this.focusIn($td);\n            }\n        } else {\n            this.setElementAttribute(cellData, $td, hasFocusedElement);\n        }\n    },\n\n    /**\n     * keyDown 이 발생했을 때, switch object 에서 필요한 공통 파라미터를 생성한다.\n     * @param {Event} keyDownEvent  이벤트 객체\n     * @return {{keyDownEvent: *, $target: (*|jQuery|HTMLElement), focusModel: (grid.focusModel|*), rowKey: *, columnName: *, keyName: *}}\n     * _keyDownSwitch 에서 사용될 공통 파라미터 객체\n     * @private\n     */\n    _getParamForKeyDownSwitch: function(keyDownEvent) {\n        var grid = this.grid,\n            keyCode = keyDownEvent.keyCode || keyDownEvent.which,\n            focused = grid.focusModel.which(),\n            rowKey = focused.rowKey,\n            columnName = focused.columnName;\n        return {\n            keyDownEvent: keyDownEvent,\n            $target: $(keyDownEvent.target),\n            focusModel: grid.focusModel,\n            rowKey: rowKey,\n            columnName: columnName,\n            keyName: keyNameMap[keyCode]\n        };\n    },\n\n    /**\n     * keyDownSwitch 를 수행한다.\n     * @param {Event} keyDownEvent 이벤트 객체\n     * @return {boolean} 정의된 keyDownSwitch 가 존재하는지 여부. Default 액션을 수행한 경우 false 를 반환한다.\n     * @private\n     */\n    _executeKeyDownSwitch: function(keyDownEvent) {\n        var keyCode = keyDownEvent.keyCode || keyDownEvent.which,\n            keyName = keyNameMap[keyCode],\n            param = this._getParamForKeyDownSwitch(keyDownEvent);\n        (this._keyDownSwitch[keyName] || this._keyDownSwitch['defaultAction']).call(this, keyDownEvent, param);\n        return !!this._keyDownSwitch[keyName];\n    },\n\n    /**\n     * keyDownSwitch 에 정의된 액션을 override 한다.\n     *\n     * @param {(String|Object)} keyName  정의된 key 이름. Object 형태일 경우 기존 keyDownSwitch 를 확장한다.\n     * @param {function} [fn] keyDown 이 발생하였을 경우 수행할 액션\n     */\n    setKeyDownSwitch: function(keyName, fn) {\n        if (typeof keyName === 'object') {\n            this._keyDownSwitch = $.extend(this._keyDownSwitch, keyName);\n        } else {\n            this._keyDownSwitch[keyName] = fn;\n        }\n    },\n\n    /**\n     * keyDown 이벤트 핸들러\n     * @param {Event} keyDownEvent  이벤트 객체\n     * @private\n     */\n    _onKeyDown: function(keyDownEvent) {\n        if (this._executeKeyDownSwitch(keyDownEvent)) {\n            keyDownEvent.preventDefault();\n        }\n    },\n\n    /**\n     * cellData에 설정된 데이터를 기반으로 classNameList 를 생성하여 반환한다.\n     * @param {Object} cellData Model 의 셀 데이터\n     * @return {Array} 생성된 css 디자인 클래스 배열\n     * @private\n     */\n    _getClassNameList: function(cellData) {\n        var focused = this.grid.focusModel.which(),\n            columnName = cellData.columnName,\n            focusedRowKey = this.grid.dataModel.getMainRowKey(focused.rowKey, columnName),\n            classNameList = [],\n            classNameMap = {},\n            privateColumnMap = {\n                '_button': true,\n                '_number': true\n            },\n            isPrivateColumnName = !!privateColumnMap[columnName];\n\n        if (focusedRowKey === cellData.rowKey) {\n            classNameMap['selected'] = true;\n            if (focused.columnName === columnName) {\n                classNameMap['focused'] = true;\n            }\n        }\n        if (cellData.className) {\n            classNameMap[cellData.className] = true;\n        }\n\n        if (cellData.isEditable &amp;&amp; !isPrivateColumnName) {\n            classNameMap['editable'] = true;\n        }\n\n        if (cellData.isDisabled) {\n            classNameMap['disabled'] = true;\n        }\n\n        tui.util.forEach(classNameMap, function(val, className) {\n            classNameList.push(className);\n        });\n\n        if (isPrivateColumnName) {\n            classNameList.push('meta_column');\n        }\n\n        return classNameList;\n    },\n\n    /**\n     * 각 셀 페인터 인스턴스마다 정의된 getContentHtml 을 이용하여\n     * 컬럼모델의 defaultValue, beforeText, afterText 를 적용한 content html 마크업 스트링 을 반환한다.\n     * @param {object} cellData Model 의 셀 데이터\n     * @return {string} 컬럼모델의 defaultValue, beforeText, afterText 를 적용한 content html 마크업 스트링\n     * @private\n     */\n    _getContentHtml: function(cellData) {\n        var columnName = cellData.columnName,\n            columnModel = this.grid.columnModel.getColumnModel(columnName),\n            editOption = columnModel.editOption || {},\n            defaultValue = columnModel.defaultValue,\n            isExisty = tui.util.isExisty,\n            beforeContent, afterContent, content;\n\n        if (!isExisty(cellData.value)) {\n            cellData.value = isExisty(defaultValue) ? defulatValue : '';\n        }\n        beforeContent = this._getExtraContent(editOption.beforeContent || editOption.beforeText, cellData);\n        afterContent = this._getExtraContent(editOption.afterContent || editOption.afterText, cellData);\n\n        content = beforeContent + this.getContentHtml(cellData) + afterContent;\n        return content;\n    },\n\n    /**\n     * beforeContent/afterContent의 내용을 반환하다.\n     * 값이 function인 경우 function을 실행해 결과값을 반환한다.\n     * @param {(string|function)} content - 내용\n     * @param {object} cellData - 셀 데이터\n     * @return {string} - 내용\n     * @private\n     */\n    _getExtraContent: function(content, cellData) {\n        var contentValue = content,\n            row, cellValue;\n\n        if (tui.util.isFunction(content)) {\n            row = this.grid.dataModel.get(cellData.rowKey);\n            cellValue = row.getHTMLEncodedString(cellData.columnName);\n            contentValue = content(cellValue, row.attributes);\n        }\n        if (!tui.util.isExisty(contentValue)) {\n            contentValue = '';\n        }\n        return contentValue;\n    },\n\n    /**\n     * 주어진 문자열을 span 태그로 감싼 HTML 코드를 반환한다.\n     * @param {string} content - 감싸질 문자열\n     * @param {string} className - span 태그의 클래스명\n     * @return {string} span 태그로 감싼 HTML 코드\n     * @private\n     */\n    _getSpanWrapContent: function(content, className) {\n        if (tui.util.isFalsy(content)) {\n            content = '';\n        }\n        return '&lt;span class=\"' + className + '\">' + content + '&lt;/span>';\n    },\n\n    /**\n     * Row Painter 에서 한번에 table 을 랜더링 할 때 사용하기 위해\n     * td 단위의 html 문자열을 반환한다.\n     * @param {object} cellData Model 의 셀 데이터\n     * @return {string} td 마크업 문자열\n     */\n    getHtml: function(cellData) {\n        var attributeString = util.getAttributesString(this.getAttributes(cellData)),\n            html;\n\n        html = this.template({\n            columnName: cellData.columnName,\n            rowSpan: cellData.rowSpan,\n            className: this._getClassNameList(cellData).join(' '),\n            editType: this.getEditType(),\n            attributeString: attributeString,\n            contentHtml: this._getContentHtml(cellData)\n        });\n        return html;\n    },\n\n    /**\n     * 이미 rendering 되어있는 TD 엘리먼트 전체를 다시 랜더링 한다.\n     * @param {object} cellData Model 의 셀 데이터\n     * @param {jQuery} $td  td 에 해당하는 jquery 로 감싼 html 엘리먼트\n     */\n    redraw: function(cellData, $td) {\n        var attributes = {\n            'class': this._getClassNameList(cellData).join(' ')\n        };\n        if (cellData.rowSpan) {\n            attributes['rowSpan'] = cellData.rowSpan;\n        }\n        attributes['edit-type'] = this.getEditType();\n        attributes = $.extend(attributes, this.getAttributes(cellData));\n        $td.attr(attributes);\n        $td.html(this._getContentHtml(cellData));\n    },\n\n    /**\n     * 인자로 받은 element 의 cellData 를 반환한다.\n     * @param {jQuery} $target  조회할 엘리먼트\n     * @return {Object} 조회한 cellData 정보\n     * @private\n     */\n    _getCellData: function($target) {\n        var cellData = this._getCellAddress($target);\n        return this.grid.renderModel.getCellData(cellData.rowKey, cellData.columnName);\n    },\n\n    /**\n     * 인자로 받은 element 로 부터 rowKey 와 columnName 을 반환한다.\n     * @param {jQuery} $target 조회할 엘리먼트\n     * @return {{rowKey: String, columnName: String}} rowKey 와 columnName 정보\n     * @private\n     */\n    _getCellAddress: function($target) {\n        return {\n            rowKey: this.getRowKey($target),\n            columnName: this.getColumnName($target)\n        };\n    },\n\n    /**\n     * cellData.columnName에 해당하는 editOption의 converter가 존재하는 경우\n     * converter 함수를 적용한 결과값을 반환한다.\n     * @param {string} value - 셀의 실제값\n     * @param {object} cellData - 모델의 셀 데이터\n     * @return {(string|null)} HTML문자열. 혹은 null\n     * @private\n     */\n    _getConvertedHtml: function(value, cellData) {\n        var columnModel = this.getColumnModel(cellData),\n            editOption = columnModel.editOption,\n            html;\n\n        if (editOption &amp;&amp; tui.util.isFunction(editOption.converter)) {\n            html = editOption.converter(value, this.grid.dataModel.get(cellData.rowKey).attributes);\n        }\n        if (tui.util.isFalsy(html)) {\n            html = null;\n        }\n        return html;\n    },\n\n    /**\n     * 인자로 받은 element 로 부터 columnName 을 반환한다.\n     * @param {jQuery} $target 조회할 엘리먼트\n     * @return {string} 컬럼명\n     */\n    getColumnName: function($target) {\n        return $target.closest('td').attr('columnName');\n    },\n\n    /**\n     * 인자로 받은 element 로 부터 rowKey 를 반환한다.\n     * @param {jQuery} $target 조회할 엘리먼트\n     * @return {string} 행의 키값\n     */\n    getRowKey: function($target) {\n        return $target.closest('tr').attr('key');\n    },\n\n    /**\n     * columnModel 을 반환한다.\n     * @param {object} cellData Model 의 셀 데이터\n     * @return {*|Object} 컬럼모델\n     */\n    getColumnModel: function(cellData) {\n        return this.grid.columnModel.getColumnModel(cellData.columnName);\n    },\n\n    /**\n     * getHtml 으로 마크업 생성시 td에 포함될 attribute object 를 반환한다.\n     * @param {Object} cellData Model 의 셀 데이터\n     * @return {Object} td 에 지정할 attribute 데이터\n     */\n    getAttributes: function(cellData) {\n        var columnModel = this.getColumnModel(cellData);\n        return {\n            align: columnModel.align || 'left'\n        };\n    },\n\n    /**\n     * focus in 상태에서 키보드 esc 를 입력했을 때 편집모드를 벗어난다. cell 내 input 을 blur 시키고, 편집모드를 벗어나는 로직.\n     * - 필요에 따라 override 한다.\n     */\n    focusOut: function() {\n        this.grid.focusModel.focusClipboard();\n    },\n\n    /**\n     * !상속받은 클래스는 이 메서드를 반드시 구현해야한다.\n     * - 자기 자신의 인스턴스의 editType 을 반환한다.\n     * @return {string} editType 'normal|button|select|button|text|text-password|text-convertible'\n     */\n    getEditType: function() {\n        return 'normal';\n    },\n\n    /**\n     * !상속받은 클래스는 이 메서드를 반드시 구현해야한다.\n     * cell 에서 키보드 enter 를 입력했을 때 편집모드로 전환. cell 내 input 에 focus 를 수행하는 로직. 필요에 따라 override 한다.\n     * @param {jQuery} $td 해당 cell 엘리먼트\n     */\n    focusIn: function($td) {}, // eslint-disable-line no-unused-vars\n\n    /**\n     * !상속받은 클래스는 이 메서드를 반드시 구현해야한다.\n     * Cell data 를 인자로 받아 &lt;td> 안에 들아갈 html string 을 반환한다.\n     * redrawAttributes 에 해당하는 프로퍼티가 변경되었을 때 수행될 로직을 구현한다.\n     * @param {object} cellData 모델의 셀 데이터\n     * @return  {string} html 마크업 문자열\n     * @example\n     * var html = this.getContentHtml();\n     * &lt;select>\n     *     &lt;option value='1'>option1&lt;/option>\n     *     &lt;option value='2'>option1&lt;/option>\n     *     &lt;option value='3'>option1&lt;/option>\n     * &lt;/select>\n     */\n    getContentHtml: function(cellData) { // eslint-disable-line no-unused-vars\n        return '';\n    },\n\n    /**\n     * !상속받은 클래스는 이 메서드를 반드시 구현해야한다.\n     * model의 redrawAttributes 에 해당하지 않는 프로퍼티의 변화가 발생했을 때 수행할 메서드\n     * redrawAttributes 에 해당하지 않는 프로퍼티가 변경되었을 때 수행할 로직을 구현한다.\n     * @param {object} cellData 모델의 셀 데이터\n     * @param {jQuery} $td 해당 cell 엘리먼트\n     * @param {Boolean} hasFocusedElement 해당 셀에 실제 focuse 된 엘리먼트가 존재하는지 여부\n     */\n    setElementAttribute: function(cellData, $td, hasFocusedElement) {} // eslint-disable-line no-unused-vars\n});\n\nmodule.exports = Cell;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"