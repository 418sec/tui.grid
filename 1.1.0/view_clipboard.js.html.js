ne.util.defineNamespace("fedoc.content", {});
fedoc.content["view_clipboard.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview 키 이벤트 핸들링 담당하는 Clipboard 정의\n * @author NHN Ent. FE Development Team\n */\n'use strict';\n\nvar View = require('../base/view');\nvar util = require('../util');\n\n/**\n * Clipboard view class\n * @module view/clipboard\n */\nvar Clipboard = View.extend(/**@lends module:view/clipboard.prototype */{\n    /**\n     * @constructs\n     * @extends module:base/view\n     */\n    initialize: function() {\n        View.prototype.initialize.apply(this, arguments);\n        this.setOwnProperties({\n            timeoutIdForKeyIn: 0,\n            isLocked: false\n        });\n    },\n\n    tagName: 'textarea',\n\n    className: 'clipboard',\n\n    events: {\n        'keydown': '_onKeyDown',\n        'focusin': '_onFocus'\n    },\n\n    /**\n     * 클립보드 focus 이벤트 핸들러\n     * @private\n     */\n    _onFocus: function() {\n        var focusModel = this.grid.focusModel,\n            focused = focusModel.which(),\n            rowIdx;\n\n        if (util.isBlank(focused.columnName)) {\n            rowIdx = util.isBlank(focused.rowKey) ? 0 : this.grid.getIndexOfRow(focused.rowKey);\n            this.grid.focusAt(rowIdx, 0);\n        }\n    },\n\n    /**\n     * 랜더링 한다.\n     * @return {View.Clipboard} this object\n     */\n    render: function() {\n        return this;\n    },\n\n    /**\n     * keyEvent 의 중복 호출을 방지하는 lock 을 설정한다.\n     * @private\n     */\n    _lock: function() {\n        clearTimeout(this.timeoutIdForKeyIn);\n        this.isLocked = true;\n        this.timeoutIdForKeyIn = setTimeout($.proxy(this._unlock, this), 10);\n    },\n\n    /**\n     * keyEvent 의 중복 호출을 방지하는 lock 을 해제한다.\n     * @private\n     */\n    _unlock: function() {\n        this.isLocked = false;\n    },\n\n    /**\n     * keyDown 이벤트 핸들러\n     * @param {event} keyDownEvent 이벤트 객체\n     * @return {boolean} False if locked\n     * @private\n     */\n    _onKeyDown: function(keyDownEvent) {\n        if (this.isLocked) {\n            keyDownEvent.preventDefault();\n            return false;\n        }\n\n        if (keyDownEvent.shiftKey &amp;&amp; (keyDownEvent.ctrlKey || keyDownEvent.metaKey)) {\n            this._keyInWithShiftAndCtrl(keyDownEvent);\n        } else if (keyDownEvent.shiftKey) {\n            this._keyInWithShift(keyDownEvent);\n        } else if (keyDownEvent.ctrlKey || keyDownEvent.metaKey) {\n            this._keyInWithCtrl(keyDownEvent);\n        } else {\n            this._keyIn(keyDownEvent);\n        }\n        this._lock();\n    },\n\n    /**\n     * ctrl, shift 둘다 눌리지 않은 상태에서의 key down 이벤트 핸들러\n     * @param {Event} keyDownEvent 이벤트 객체\n     * @private\n     */\n    _keyIn: function(keyDownEvent) { // eslint-disable-line complexity\n        var grid = this.grid,\n            keyMap = grid.keyMap,\n            focusModel = grid.focusModel,\n            selectionModel = grid.selectionModel,\n            focused = focusModel.which(),\n            rowKey = focused.rowKey,\n            columnName = focused.columnName,\n            displayRowCount = grid.dimensionModel.getDisplayRowCount(),\n            isKeyIdentified = true,\n            keyCode = keyDownEvent.keyCode || keyDownEvent.which;\n\n        if (util.isBlank(focused.rowKey)) {\n            return;\n        }\n\n        switch (keyCode) {\n            case keyMap['UP_ARROW']:\n                grid.focus(focusModel.prevRowKey(), columnName, true);\n                break;\n            case keyMap['DOWN_ARROW']:\n                grid.focus(focusModel.nextRowKey(), columnName, true);\n                break;\n            case keyMap['LEFT_ARROW']:\n                grid.focus(rowKey, focusModel.prevColumnName(), true);\n                break;\n            case keyMap['RIGHT_ARROW']:\n                grid.focus(rowKey, focusModel.nextColumnName(), true);\n                break;\n            case keyMap['PAGE_UP']:\n                grid.focus(focusModel.prevRowKey(displayRowCount - 1), columnName, true);\n                break;\n            case keyMap['PAGE_DOWN']:\n                grid.focus(focusModel.nextRowKey(displayRowCount - 1), columnName, true);\n                break;\n            case keyMap['HOME']:\n                grid.focus(rowKey, focusModel.firstColumnName(), true);\n                break;\n            case keyMap['END']:\n                grid.focus(rowKey, focusModel.lastColumnName(), true);\n                break;\n            //space 와 enter 는 동일동작\n            case keyMap['SPACE']:\n            case keyMap['ENTER']:\n                this._onEnterSpace(rowKey, columnName);\n                break;\n            case keyMap['DEL']:\n                this._del(rowKey, columnName);\n                break;\n            case keyMap['TAB']:\n                grid.focusIn(rowKey, focusModel.nextColumnName(), true);\n                break;\n            default:\n                isKeyIdentified = false;\n                break;\n        }\n        if (isKeyIdentified) {\n            keyDownEvent.preventDefault();\n        }\n        selectionModel.end();\n    },\n\n    /**\n     * enter 또는 space 가 입력되었을 때, 처리하는 로직\n     * @param {(number|string)} rowKey 키 입력이 발생한 엘리먼트의 rowKey\n     * @param {string} columnName 키 입력이 발생한 엘리먼트의 컬럼명\n     * @private\n     */\n    _onEnterSpace: function(rowKey, columnName) {\n        var cellInstance,\n            grid = this.grid,\n            editType = this.grid.columnModel.getEditType(columnName);\n        if (editType === '_button') {\n            cellInstance = this.grid.cellFactory.getInstance(editType);\n            cellInstance.toggle(grid.getElement(rowKey, columnName));\n        } else {\n            grid.focusIn(rowKey, columnName);\n        }\n    },\n\n    /**\n     * shift 가 눌린 상태에서의 key down event handler\n     * @param {event} keyDownEvent 이벤트 객체\n     * @private\n     */\n    _keyInWithShift: function(keyDownEvent) { // eslint-disable-line complexity\n        var grid = this.grid,\n            keyMap = grid.keyMap,\n            focusModel = grid.focusModel,\n            columnModelList = grid.columnModel.getVisibleColumnModelList(),\n            focusedIndex = grid.focusModel.indexOf(),\n            focused = focusModel.which(),\n            isKeyIdentified = true,\n            displayRowCount = grid.dimensionModel.getDisplayRowCount(),\n            keyCode = keyDownEvent.keyCode || keyDownEvent.which;\n\n        switch (keyCode) {\n            case keyMap['UP_ARROW']:\n                this._updateSelectionByKeyIn(focusModel.prevRowIndex(), focusedIndex.columnIdx);\n                break;\n            case keyMap['DOWN_ARROW']:\n                this._updateSelectionByKeyIn(focusModel.nextRowIndex(), focusedIndex.columnIdx);\n                break;\n            case keyMap['LEFT_ARROW']:\n                this._updateSelectionByKeyIn(focusedIndex.rowIdx, focusModel.prevColumnIndex());\n                break;\n            case keyMap['RIGHT_ARROW']:\n                this._updateSelectionByKeyIn(focusedIndex.rowIdx, focusModel.nextColumnIndex());\n                break;\n            case keyMap['PAGE_UP']:\n                this._updateSelectionByKeyIn(focusModel.prevRowIndex(displayRowCount - 1), focusedIndex.columnIdx);\n                break;\n            case keyMap['PAGE_DOWN']:\n                this._updateSelectionByKeyIn(focusModel.nextRowIndex(displayRowCount - 1), focusedIndex.columnIdx);\n                break;\n            case keyMap['HOME']:\n                this._updateSelectionByKeyIn(focusedIndex.rowIdx, 0);\n                break;\n            case keyMap['END']:\n                this._updateSelectionByKeyIn(focusedIndex.rowIdx, columnModelList.length - 1);\n                break;\n            case keyMap['ENTER']:\n                break;\n            case keyMap['TAB']:\n                grid.focusIn(focused.rowKey, focusModel.prevColumnName(), true);\n                break;\n            default:\n                isKeyIdentified = false;\n                break;\n        }\n        if (isKeyIdentified) {\n            keyDownEvent.preventDefault();\n        }\n    },\n\n    /**\n     * ctrl 가 눌린 상태에서의 key down event handler\n     * @param {event} keyDownEvent 이벤트 객체\n     * @private\n     */\n    _keyInWithCtrl: function(keyDownEvent) {\n        var grid = this.grid,\n            keyMap = grid.keyMap,\n            focusModel = grid.focusModel,\n            keyCode = keyDownEvent.keyCode || keyDownEvent.which;\n\n        switch (keyCode) {\n            case keyMap['CHAR_A']:\n                this.grid.selectionModel.selectAll();\n                break;\n            case keyMap['CHAR_C']:\n                this._copyToClipboard();\n                break;\n            case keyMap['HOME']:\n                grid.focus(focusModel.firstRowKey(), focusModel.firstColumnName(), true);\n                break;\n            case keyMap['END']:\n                grid.focus(focusModel.lastRowKey(), focusModel.lastColumnName(), true);\n                break;\n            case keyMap['CHAR_V']:\n                this._paste();\n                break;\n            default:\n                break;\n        }\n    },\n\n    /**\n     * paste date\n     * @private\n     */\n    _paste: function() {\n        // pressing v long time, clear clipboard to keep final paste date\n        this._clearClipBoard();\n        if (this.pasting) {\n            return;\n        }\n\n        this.pasting = true;\n        this._onKeyupCharV();\n    },\n\n    /**\n     * keyup event attach\n     * @private\n     */\n    _onKeyupCharV: function() {\n        this.$el.on('keyup', $.proxy(this.onKeyupCharV, this));\n    },\n\n    onKeyupCharV: function() {\n        this._pasteToGrid();\n        this.pasting = false;\n    },\n\n   /**\n     * clipboard textarea clear\n     * @private\n     */\n    _clearClipBoard: function() {\n        this.$el.val('');\n    },\n\n    /**\n     * paste text data\n     * @private\n     */\n    _pasteToGrid: function() {\n        var result = this._getProcessClipBoardData();\n        this.$el.off('keyup');\n        this.grid.paste(result);\n    },\n\n    /**\n     * process data for paste to grid\n     * @private\n     * @return {Array.&lt;Array.&lt;string>>} result\n     */\n    _getProcessClipBoardData: function() {\n        var text = this.$el.val(),\n            result = text.split('\\n'),\n            i = 0,\n            len = result.length;\n\n        for (; i &lt; len; i += 1) {\n            result[i] = result[i].split('\\t');\n        }\n        return result;\n    },\n\n    /**\n     * ctrl, shift 둘다 눌린 상태에서의 key down event handler\n     * @param {event} keyDownEvent 이벤트 객체\n     * @private\n     */\n    _keyInWithShiftAndCtrl: function(keyDownEvent) {\n        var grid = this.grid,\n            keyMap = grid.keyMap,\n            isKeyIdentified = true,\n            columnModelList = grid.columnModel.getVisibleColumnModelList(),\n            keyCode = keyDownEvent.keyCode || keyDownEvent.which;\n\n        switch (keyCode) {\n            case keyMap['HOME']:\n                this._updateSelectionByKeyIn(0, 0);\n                break;\n            case keyMap['END']:\n                this._updateSelectionByKeyIn(grid.dataModel.length - 1, columnModelList.length - 1);\n                break;\n            default:\n                isKeyIdentified = false;\n                break;\n        }\n        if (isKeyIdentified) {\n            keyDownEvent.preventDefault();\n        }\n    },\n\n    /**\n     * text type 의 editOption cell 의 data 를 빈 스트링으로 세팅한다.\n     * selection 영역이 지정되어 있다면 selection 영역에 해당하는 모든 셀.\n     * selection 영역이 지정되어 있지 않다면 focus된 셀\n     * @private\n     */\n    _del: function() {\n        var grid = this.grid,\n            selectionModel = grid.selectionModel,\n            dataModel = grid.dataModel,\n            focused = grid.focusModel.which(),\n            columnModelList = grid.columnModel.getVisibleColumnModelList(),\n            rowKey = focused.rowKey,\n            columnName = focused.columnName,\n            range, i, j;\n\n        if (selectionModel.hasSelection()) {\n            //다수의 cell 을 제거 할 때에는 silent 로 데이터를 변환한 후 한번에 랜더링을 refresh 한다.\n            range = selectionModel.get('range');\n            for (i = range.row[0]; i &lt; range.row[1] + 1; i += 1) {\n                rowKey = dataModel.at(i).get('rowKey');\n                for (j = range.column[0]; j &lt; range.column[1] + 1; j += 1) {\n                    columnName = columnModelList[j]['columnName'];\n                    grid.del(rowKey, columnName, true);\n                }\n            }\n            grid.renderModel.refresh(true);\n        } else {\n            grid.del(rowKey, columnName);\n        }\n    },\n\n    /**\n     * keyIn 으로 selection 영역을 update 한다. focus 로직도 함께 수행한다.\n     * @param {Number} rowIndex 행의 index 정보\n     * @param {Number} columnIndex 열의 index 정보\n     * @private\n     */\n    _updateSelectionByKeyIn: function(rowIndex, columnIndex) {\n        var selectionModel = this.grid.selectionModel,\n            focused = this.grid.focusModel.indexOf();\n\n        if (!selectionModel.hasSelection()) {\n            selectionModel.start(focused.rowIdx, focused.columnIdx);\n        }\n        selectionModel.update(rowIndex, columnIndex);\n        this.grid.focusAt(rowIndex, columnIndex, true);\n    },\n\n    /**\n     * clipboard 에 설정될 문자열 반환한다.\n     * @return {String} 데이터를 text 형태로 변환한 문자열\n     * @private\n     */\n    _getClipboardString: function() {\n        var text,\n            selectionModel = this.grid.selectionModel,\n            focused = this.grid.focusModel.which();\n        if (selectionModel.hasSelection()) {\n            text = this.grid.selectionModel.getValuesToString();\n        } else {\n            text = this.grid.dataModel.get(focused.rowKey).getVisibleText(focused.columnName);\n        }\n        return text;\n    },\n\n    /**\n     * 현재 그리드의 data 를 clipboard 에 copy 한다.\n     * @private\n     */\n     /* istanbul ignore next */\n    _copyToClipboard: function() {\n        var text = this._getClipboardString();\n        if (window.clipboardData) {\n            window.clipboardData.setData('Text', text);\n        } else {\n            this.$el.val(text).select();\n        }\n    }\n});\n\nmodule.exports = Clipboard;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"