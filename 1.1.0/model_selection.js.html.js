ne.util.defineNamespace("fedoc.content", {});
fedoc.content["model_selection.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Selection Model class\n * @author NHN Ent. FE Development Team\n */\n'use strict';\n\nvar Model = require('../base/model');\n\n/**\n *  Selection Model class\n *  @module model/selection\n */\nvar Selection = Model.extend(/**@lends module:model/selection.prototype */{\n    /**\n     * @constructs\n     * @extends module:base/view\n     */\n    initialize: function() {\n        Model.prototype.initialize.apply(this, arguments);\n\n        this.setOwnProperties({\n            inputRange: null,\n            intervalIdForAutoScroll: null,\n            scrollPixelScale: 40,\n            _isEnabled: true\n        });\n\n        this.listenTo(this.grid.dataModel, 'add remove sort reset', this.end);\n    },\n\n    defaults: {\n        /**\n         * Selection range\n         * ex) {row: [0, 1], column: [1, 2]}\n         * @type {{row: array, column: array}}\n         */\n        range: null\n    },\n\n    /**\n     * Enables the selection.\n     */\n    enable: function() {\n        if (this.grid.option('useDataCopy')) {\n            this._isEnabled = true;\n        }\n    },\n\n    /**\n     * Disables the selection.\n     */\n    disable: function() {\n        this.end();\n        this._isEnabled = false;\n    },\n\n    /**\n     * Returns whether the selection is enabled.\n     * @return {boolean} True is selection is enabled.\n     */\n    isEnabled: function() {\n        return this._isEnabled;\n    },\n\n    /**\n     * Starts the selection.\n     * @param {Number} rowIndex - Row index\n     * @param {Number} columnIndex - Column index\n     */\n    start: function(rowIndex, columnIndex) {\n        if (!this._isEnabled) {\n            return;\n        }\n        this.inputRange = {\n            row: [rowIndex, rowIndex],\n            column: [columnIndex, columnIndex]\n        };\n        this._resetRangeAttribute();\n        this.grid.focusClipboard();\n    },\n\n    /**\n     * Starts the selection by mouse position.\n     * @param {number} pageX - X position relative to the document\n     * @param {number} pageY - Y position relative to the document\n     */\n    startByMousePosition: function(pageX, pageY) {\n        var pos = this._getIndexFromMousePosition(pageX, pageY);\n        this.start(pos.row, pos.column);\n    },\n\n    /**\n     * Updates the selection range.\n     * @param {Number} rowIndex - Row index\n     * @param {Number} columnIndex - Column index\n     */\n    update: function(rowIndex, columnIndex) {\n        var focused;\n\n        if (!this._isEnabled || !this.inputRange || rowIndex &lt; 0 || columnIndex &lt; 0) {\n            return;\n        }\n\n        if (!this.hasSelection()) {\n            focused = this.grid.focusModel.indexOf(true);\n            this.start(focused.rowIdx, focused.columnIdx);\n        }\n        this.inputRange.row[1] = rowIndex;\n        this.inputRange.column[1] = columnIndex;\n        this._resetRangeAttribute();\n        this.grid.focusClipboard();\n        this.grid.focusAt(rowIndex, columnIndex);\n    },\n\n    /**\n     * Updates the selection range by mouse position.\n     * @param {number} pageX - X position relative to the document\n     * @param {number} pageY - Y position relative to the document\n     */\n    updateByMousePosition: function(pageX, pageY) {\n        var pos = this._getIndexFromMousePosition(pageX, pageY),\n            self = this;\n\n        this.stopAutoScroll();\n        if (this._isAutoScrollable(pos.overflowX, pos.overflowY)) {\n            this.intervalIdForAutoScroll = setInterval(\n                _.bind(this._adjustScroll, this, pos.overflowX, pos.overflowY)\n            );\n        }\n        this.update(pos.row, pos.column);\n    },\n\n    /**\n     * selection 영역 선택을 종료하고 selection 데이터를 초기화한다.\n     */\n    end: function() {\n        this.inputRange = null;\n        this.set('range', null);\n    },\n\n    /**\n     * Stops the auto-scroll interval.\n     */\n    stopAutoScroll: function() {\n        if (!_.isNull(this.intervalIdForAutoScroll)) {\n            clearInterval(this.intervalIdForAutoScroll);\n            this.intervalIdForAutoScroll = null;\n        }\n    },\n\n    /**\n     * Selects all data range.\n     */\n    selectAll: function() {\n        if (this._isEnabled) {\n            this.start(0, 0);\n            this.update(this.grid.dataModel.length - 1, this.grid.columnModel.getVisibleColumnModelList().length - 1);\n        }\n    },\n\n    /**\n     * Returns the row and column indexes of the starting position.\n     * @return {{rowIdx: number, columnIdx: number}} Objects containing indexes\n     */\n    getStartIndex: function() {\n        var range = this.get('range');\n        return {\n            rowIdx: range.row[0],\n            columnIdx: range.column[0]\n        };\n    },\n\n    /**\n     * Returns the row and column indexes of the ending position.\n     * @return {{rowIdx: number, columnIdx: number}} Objects containing indexes\n     */\n    getEndIndex: function() {\n        var range = this.get('range');\n        return {\n            rowIdx: range.row[1],\n            columnIdx: range.column[1]\n        };\n    },\n\n    /**\n     * selection 데이터가 존재하는지 확인한다.\n     * @return {boolean} selection 데이터 존재여부\n     */\n    hasSelection: function() {\n        return !!this.get('range');\n    },\n\n    /**\n     * Returns the string value of all cells in the selection range as a single string.\n     * @return {String} string value\n     */\n    getValuesToString: function() {\n        var grid = this.grid,\n            range = this.get('range'),\n            columnModelList, rowList, columnNameList, rowValues;\n\n        columnModelList = grid.columnModel.getVisibleColumnModelList().slice(range.column[0], range.column[1] + 1);\n        rowList = grid.dataModel.slice(range.row[0], range.row[1] + 1);\n\n        columnNameList = _.pluck(columnModelList, 'columnName');\n        rowValues = _.map(rowList, function(row) {\n            var tmpString = _.map(columnNameList, function(columnName) {\n                return row.getVisibleText(columnName);\n            });\n            return tmpString.join('\\t');\n        });\n\n        return rowValues.join('\\n');\n    },\n\n    /**\n     * 마우스 드래그로 selection 선택 시 auto scroll 조건에 해당하는지 반환한다.\n     * @param {Number} overflowX    가로축 기준 영역 overflow 값\n     * @param {Number} overflowY    세로축 기준 영역 overflow 값\n     * @return {boolean} overflow 되었는지 여부\n     * @private\n     */\n    _isAutoScrollable: function(overflowX, overflowY) {\n        return !(overflowX === 0 &amp;&amp; overflowY === 0);\n    },\n\n    /**\n     * Adjusts scrollTop and scrollLeft value.\n     * @param {Number} overflowX    가로축 기준 영역 overflow 값\n     * @param {Number} overflowY    세로축 기준 영역 overflow 값\n     * @private\n     */\n    _adjustScroll: function(overflowX, overflowY) {\n        var renderModel = this.grid.renderModel;\n\n        if (overflowX) {\n            this._adjustScrollLeft(overflowX, renderModel.get('scrollLeft'), renderModel.get('maxScrollLeft'));\n        }\n        if (overflowY) {\n            this._adjustScrollTop(overflowY, renderModel.get('scrollTop'), renderModel.get('maxScrollTop'));\n        }\n    },\n\n    /**\n     * Adjusts scrollLeft value.\n     * @param  {number} overflowX - 1 | 0 | -1\n     * @param  {number} scrollLeft - Current scrollLeft value\n     * @param  {number} maxScrollLeft - Max scrollLeft value\n     * @private\n     */\n    _adjustScrollLeft: function(overflowX, scrollLeft, maxScrollLeft) {\n        var adjusted = scrollLeft,\n            pixelScale = this.scrollPixelScale;\n\n        if (overflowX &lt; 0) {\n            adjusted = Math.max(0, scrollLeft - pixelScale);\n        } else if (overflowX > 0) {\n            adjusted = Math.min(maxScrollLeft, scrollLeft + pixelScale);\n        }\n        this.grid.renderModel.set('scrollLeft', adjusted);\n    },\n\n    /**\n     * Adjusts scrollTop value.\n     * @param  {number} overflowY - 1 | 0 | -1\n     * @param  {number} scrollTop - Current scrollTop value\n     * @param  {number} maxScrollTop - Max scrollTop value\n     * @private\n     */\n    _adjustScrollTop: function(overflowY, scrollTop, maxScrollTop) {\n        var adjusted = scrollTop,\n            pixelScale = this.scrollPixelScale;\n\n        if (overflowY &lt; 0) {\n            adjusted = Math.max(0, scrollTop - pixelScale);\n        } else if (overflowY > 0) {\n            adjusted = Math.min(maxScrollTop, scrollTop + pixelScale);\n        }\n        this.grid.renderModel.set('scrollTop', adjusted);\n    },\n\n    /**\n     * 마우스 위치 정보에 해당하는 row 와 column index 를 반환한다.\n     * @param {Number} pageX    마우스 x좌표\n     * @param {Number} pageY    마우스 y 좌표\n     * @return {{row: number, column: number, overflowX: number, overflowY: number}} row, column의 인덱스 정보와 x, y축 overflow 정보.\n     * @private\n     */\n    _getIndexFromMousePosition: function(pageX, pageY) {\n        var containerPos = this._getContainerPosition(pageX, pageY),\n            dimensionModel = this.grid.dimensionModel,\n            renderModel = this.grid.renderModel,\n            columnWidthList = dimensionModel.getColumnWidthList(),\n            scrollTop = renderModel.get('scrollTop'),\n            scrollLeft = renderModel.get('scrollLeft'),\n            totalColumnWidth = dimensionModel.getFrameWidth(),\n            dataPosY = containerPos.pageY + scrollTop,\n            dataPosX = containerPos.pageX,\n            overflowX = 0,\n            overflowY = 0,\n            isLside = (dimensionModel.get('lsideWidth') > containerPos.pageX),\n            len = columnWidthList.length,\n            curWidth = 0,\n            height = this.grid.option('scrollX') ?\n                dimensionModel.get('bodyHeight') - this.grid.scrollBarSize : dimensionModel.get('bodyHeight'),\n            width = this.grid.option('scrollY') ?\n                dimensionModel.get('width') - this.grid.scrollBarSize : dimensionModel.get('width'),\n            rowIdx, columnIdx;\n\n        if (!isLside) {\n            dataPosX = dataPosX + scrollLeft;\n        }\n        rowIdx = Math.max(0, Math.min(Math.floor(dataPosY / (dimensionModel.get('rowHeight') + 1)), this.grid.dataModel.length - 1));\n\n        if (containerPos.pageY &lt; 0) {\n            overflowY = -1;\n        } else if (containerPos.pageY > height) {\n            overflowY = 1;\n        }\n\n        if (containerPos.pageX &lt; 0) {\n            overflowX = -1;\n        } else if (containerPos.pageX > width) {\n            overflowX = 1;\n        }\n\n        if (dataPosX &lt; 0) {\n            columnIdx = 0;\n        } else if (totalColumnWidth &lt; dataPosX) {\n            columnIdx = len - 1;\n        } else {\n            tui.util.forEachArray(columnWidthList, function(columnWidth, i) {\n                curWidth += columnWidth + 1;\n                if (dataPosX &lt;= curWidth) {\n                    columnIdx = i;\n                    return false;\n                }\n            });\n        }\n\n        return {\n            row: rowIdx,\n            column: columnIdx - this.grid.columnModel.getVisibleMetaColumnCount(),\n            overflowX: overflowX,\n            overflowY: overflowY\n        };\n    },\n\n    /**\n     * Expands the 'this.inputRange' if rowspan data exists, and resets the 'range' attributes to the value.\n     * @private\n     */\n    _resetRangeAttribute: function() {\n        var dataModel = this.grid.dataModel,\n            spannedRange = null,\n            tmpRowRange;\n\n        if (this.inputRange) {\n            spannedRange = {\n                row: _.sortBy(this.inputRange.row),\n                column: _.sortBy(this.inputRange.column)\n            }\n            if (dataModel.isRowSpanEnable()) {\n                do {\n                    tmpRowRange = _.assign([], spannedRange.row);\n                    spannedRange = this._getRowSpannedIndex(spannedRange);\n                } while (spannedRange.row[0] !== tmpRowRange[0] || spannedRange.row[1] !== tmpRowRange[1]);\n            }\n        }\n        this.set('range', spannedRange);\n    },\n\n    /**\n     * 마우스 위치 정보에 해당하는 grid container 기준 pageX 와 pageY 를 반환한다.\n     * @param {Number} pageX    마우스 x 좌표\n     * @param {Number} pageY    마우스 y 좌표\n     * @return {{pageX: number, pageY: number}} 그리드 container 기준의 pageX, pageY 값\n     * @private\n     */\n    _getContainerPosition: function(pageX, pageY) {\n        var dimensionModel = this.grid.dimensionModel,\n            containerPosX = pageX - dimensionModel.get('offsetLeft'),\n            containerPosY = pageY - (dimensionModel.get('offsetTop') + dimensionModel.get('headerHeight') + 2);\n\n        return {\n            pageX: containerPosX,\n            pageY: containerPosY\n        };\n    },\n\n    /**\n     * row start index 기준으로 rowspan 을 확인하며 startRangeList 업데이트 하는 함수\n     * @param {object} param - parameters\n     * @private\n     */\n    _concatRowSpanIndexFromStart: function(param) {\n        var startIndex = param.startIndex,\n            endIndex = param.endIndex,\n            columnName = param.columnName,\n            rowSpanData = param.startRowSpanDataMap &amp;&amp; param.startRowSpanDataMap[columnName],\n            startIndexList = param.startIndexList,\n            endIndexList = param.endIndexList,\n            spannedIndex;\n\n        if (!rowSpanData) {\n            return;\n        }\n\n        if (!rowSpanData['isMainRow']) {\n            spannedIndex = startIndex + rowSpanData['count'];\n            startIndexList.push(spannedIndex);\n        } else {\n            spannedIndex = startIndex + rowSpanData['count'] - 1;\n            if (spannedIndex > endIndex) {\n                endIndexList.push(spannedIndex);\n            }\n        }\n    },\n\n    /**\n     * row end index 기준으로 rowspan 을 확인하며 endRangeList 를 업데이트 하는 함수\n     * @param {object} param - parameters\n     * @private\n     */\n    _concatRowSpanIndexFromEnd: function(param) {\n        var endIndex = param.endIndex,\n            columnName = param.columnName,\n            rowSpanData = param.endRowSpanDataMap &amp;&amp; param.endRowSpanDataMap[columnName],\n            endIndexList = param.endIndexList,\n            dataModel = param.dataModel,\n            spannedIndex, tmpRowSpanData;\n\n        if (!rowSpanData) {\n            return;\n        }\n\n        if (!rowSpanData['isMainRow']) {\n            spannedIndex = endIndex + rowSpanData['count'];\n            tmpRowSpanData = dataModel.at(spannedIndex).getRowSpanData(columnName);\n            spannedIndex += tmpRowSpanData['count'] - 1;\n            if (spannedIndex > endIndex) {\n                endIndexList.push(spannedIndex);\n            }\n        } else {\n            spannedIndex = endIndex + rowSpanData['count'] - 1;\n            endIndexList.push(spannedIndex);\n        }\n    },\n\n    /**\n     * rowSpan 된 Index range 를 반환한다.\n     * @param {{row: Array, column: Array}} spannedRange 인덱스 정보\n     * @returns {{row: Array, column: Array}} New Range\n     * @private\n     */\n    _getRowSpannedIndex: function(spannedRange) {\n        var columnModelList = this.grid.columnModel.getVisibleColumnModelList()\n                .slice(spannedRange.column[0], spannedRange.column[1] + 1),\n            dataModel = this.grid.dataModel,\n            startIndexList = [spannedRange.row[0]],\n            endIndexList = [spannedRange.row[1]],\n            startRow = dataModel.at(spannedRange.row[0]),\n            endRow = dataModel.at(spannedRange.row[1]),\n            newSpannedRange = $.extend({}, spannedRange),\n            startRowSpanDataMap, endRowSpanDataMap, columnName, param;\n\n        if (!startRow || !endRow) {\n            return newSpannedRange;\n        }\n\n        startRowSpanDataMap = dataModel.at(spannedRange.row[0]).getRowSpanData();\n        endRowSpanDataMap = dataModel.at(spannedRange.row[1]).getRowSpanData();\n\n        //모든 열을 순회하며 각 열마다 설정된 rowSpan 정보에 따라 인덱스를 업데이트 한다.\n        _.each(columnModelList, function(columnModel) {\n            columnName = columnModel['columnName'];\n            param = {\n                columnName: columnName,\n                startIndex: spannedRange.row[0],\n                endIndex: spannedRange.row[1],\n                endRowSpanDataMap: endRowSpanDataMap,\n                startRowSpanDataMap: startRowSpanDataMap,\n                startIndexList: startIndexList,\n                endIndexList: endIndexList,\n                dataModel: dataModel\n            };\n            this._concatRowSpanIndexFromStart(param);\n            this._concatRowSpanIndexFromEnd(param);\n        }, this);\n\n        newSpannedRange.row = [Math.min.apply(null, startIndexList), Math.max.apply(null, endIndexList)];\n        return newSpannedRange;\n    }\n});\n\nmodule.exports = Selection;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"