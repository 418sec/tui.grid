tui.util.defineNamespace("fedoc.content", {});
fedoc.content["model_data_row.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Grid 의 Data Source 에 해당하는 Model 정의\n * @author NHN Ent. FE Development Team\n */\n'use strict';\n\nvar Model = require('../../base/model');\nvar ExtraDataManager = require('./extraDataManager');\nvar util = require('../../common/util');\n\n// Propertie names that indicate meta data\nvar PRIVATE_PROPERTIES = [\n    '_button',\n    '_number',\n    '_extraData'\n];\n\n// Error code for validtaion\nvar VALID_ERR_REQUIRED = 'REQUIRED';\n\n/**\n * Data 중 각 행의 데이터 모델 (DataSource)\n * @module model/data/row\n * @extends module:base/model\n */\nvar Row = Model.extend(/**@lends module:model/data/row.prototype */{\n    /**\n     * @constructs\n     */\n    initialize: function() {\n        Model.prototype.initialize.apply(this, arguments);\n        this.extraDataManager = new ExtraDataManager(this.get('_extraData'));\n\n        this.columnModel = this.collection.columnModel;\n        this.validateMap = {};\n        this.on('change', this._onChange, this);\n    },\n\n    idAttribute: 'rowKey',\n\n    /**\n     * Overrides Backbone's parse method for extraData not to be null.\n     * @override\n     * @param  {object} data - initial data\n     * @returns {object} - parsed data\n     */\n    parse: function(data) {\n        if (!data._extraData) {\n            data._extraData = {};\n        }\n        return data;\n    },\n\n    /**\n     * Event handler for change event in _extraData.\n     * Reset _extraData value with cloned object to trigger 'change:_extraData' event.\n     */\n    _triggerExtraDataChangeEvent: function() {\n        this.trigger('extraDataChanged', this.get('_extraData'));\n    },\n\n    /**\n     * Event handler for 'change' event.\n     * Executes callback functions, sync rowspan data, and validate data.\n     * @private\n     */\n    _onChange: function() {\n        var publicChanged = _.omit(this.changed, PRIVATE_PROPERTIES);\n\n        if (this.isDuplicatedPublicChanged(publicChanged)) {\n            return;\n        }\n        _.each(publicChanged, function(value, columnName) {\n            var columnModel = this.columnModel.getColumnModel(columnName);\n            if (!columnModel) {\n                return;\n            }\n            if (!this._executeChangeBeforeCallback(columnName)) {\n                return;\n            }\n            this.collection.syncRowSpannedData(this, columnName, value);\n            this._executeChangeAfterCallback(columnName);\n            this.validateCell(columnName, true);\n        }, this);\n    },\n\n    /**\n     * Validate the cell data of given columnName and returns the error code.\n     * @param  {Object} columnName - Column name\n     * @returns {String} Error code\n     * @private\n     */\n    _validateCellData: function(columnName) {\n        var columnModel = this.columnModel.getColumnModel(columnName),\n            value = this.get(columnName),\n            errorCode = '';\n\n        if (columnModel.isRequired &amp;&amp; util.isBlank(value)) {\n            errorCode = VALID_ERR_REQUIRED;\n        }\n        return errorCode;\n    },\n\n    /**\n     * Validate a cell of given columnName.\n     * If the data is invalid, add 'invalid' class name to the cell.\n     * @param {String} columnName - Target column name\n     * @param {Boolean} isDataChanged - True if data is changed (called by onChange handler)\n     * @returns {String} - Error code\n     */\n    validateCell: function(columnName, isDataChanged) {\n        var errorCode;\n\n        if (!isDataChanged &amp;&amp; (columnName in this.validateMap)) {\n            return this.validateMap[columnName];\n        }\n\n        errorCode = this._validateCellData(columnName);\n        if (errorCode) {\n            this.addCellClassName(columnName, 'invalid');\n        } else {\n            this.removeCellClassName(columnName, 'invalid');\n        }\n        this.validateMap[columnName] = errorCode;\n\n        return errorCode;\n    },\n\n    /**\n     * columnModel 에 정의된 changeCallback 을 수행할 때 전달핼 이벤트 객체를 생성한다.\n     * @param {String} columnName 컬럼명\n     * @returns {{rowKey: (number|string), columnName: string, columnData: *, instance: {object}}}\n     *          changeCallback 에 전달될 이벤트 객체\n     * @private\n     */\n    _createChangeCallbackEvent: function(columnName) {\n        return {\n            rowKey: this.get('rowKey'),\n            columnName: columnName,\n            value: this.get(columnName),\n            instance: tui.Grid.getInstanceById(this.collection.gridId)\n        };\n    },\n\n    /**\n     * columnModel 에 정의된 changeBeforeCallback 을 수행한다.\n     * changeBeforeCallback 의 결과가 false 일 때, 데이터를 복원후 false 를 반환한다.\n     * @param {String} columnName   컬럼명\n     * @returns {boolean} changeBeforeCallback 수행 결과값\n     * @private\n     */\n    _executeChangeBeforeCallback: function(columnName) {\n        var columnModel = this.columnModel.getColumnModel(columnName),\n            changeEvent, obj;\n\n        if (columnModel.editOption &amp;&amp; columnModel.editOption.changeBeforeCallback) {\n            changeEvent = this._createChangeCallbackEvent(columnName);\n\n            //beforeChangeCallback 의 결과값이 false 라면 restore 후 false 를 반환한다.\n            if (columnModel.editOption.changeBeforeCallback(changeEvent) === false) {\n                obj = {};\n                obj[columnName] = this.previous(columnName);\n                this.set(obj);\n                this.trigger('restore', {\n                    changed: obj\n                });\n                return false;\n            }\n        }\n        return true;\n    },\n\n    /**\n     * columnModel 에 정의된 changeAfterCallback 을 수행한다.\n     * @param {String} columnName - 컬럼명\n     * @returns {boolean} changeAfterCallback 수행 결과값\n     * @private\n     */\n    _executeChangeAfterCallback: function(columnName) {\n        var columnModel = this.columnModel.getColumnModel(columnName),\n            changeEvent;\n\n        if (columnModel.editOption &amp;&amp; columnModel.editOption.changeAfterCallback) {\n            changeEvent = this._createChangeCallbackEvent(columnName);\n            return !!(columnModel.editOption.changeAfterCallback(changeEvent));\n        }\n        return true;\n    },\n\n    /**\n     * Returns the Array of private property names\n     * @returns {array} An array of private property names\n     */\n    getPrivateProperties: function() {\n        return PRIVATE_PROPERTIES;\n    },\n\n    /**\n     * Returns the object that contains rowState info.\n     * @returns {{isDisabled: boolean, isDisabledCheck: boolean, isChecked: boolean}} rowState 정보\n     */\n    getRowState: function() {\n        return this.extraDataManager.getRowState();\n    },\n\n    /**\n     * Returns an array of all className, related with given columnName.\n     * @param {String} columnName - Column name\n     * @returns {Array.&lt;String>} - An array of classNames\n     */\n    getClassNameList: function(columnName) {\n        var columnModel = this.columnModel.getColumnModel(columnName),\n            classNameList = this.extraDataManager.getClassNameList(columnName);\n\n        if (columnModel.className) {\n            classNameList.push(columnModel.className);\n        }\n        if (columnModel.isEllipsis) {\n            classNameList.push('ellipsis');\n        }\n        if (columnModel.isRequired) {\n            classNameList.push('required');\n        }\n        return this._makeUniqueStringArray(classNameList);\n    },\n\n    /**\n     * Returns a new array, which splits all comma-separated strings in the targetList and removes duplicated item.\n     * @param  {Array} targetArray - Target array\n     * @returns {Array} - New array\n     */\n    _makeUniqueStringArray: function(targetArray) {\n        var singleStringArray = _.uniq(targetArray.join(' ').split(' '));\n        return _.without(singleStringArray, '');\n    },\n\n    /**\n     * columnName 에 해당하는 셀의 편집 가능여부와 disabled 상태 여부를 반환한다.\n     * @param {String} columnName   컬럼명\n     * @returns {{isEditable: boolean, isDisabled: boolean}} 편집 가능여부와 disabled 상태 정보\n     */\n    getCellState: function(columnName) {\n        var notEditableTypeList = ['_number', 'normal'],\n            columnModel = this.columnModel,\n            isDisabled = false,\n            isEditable = true,\n            editType = columnModel.getEditType(columnName),\n            rowState, relationResult;\n\n\n        relationResult = this.getRelationResult(['isDisabled', 'isEditable'])[columnName];\n        rowState = this.getRowState();\n\n        if (columnName === '_button') {\n            isDisabled = rowState.isDisabledCheck;\n        } else {\n            isDisabled = rowState.isDisabled;\n        }\n        isDisabled = isDisabled || !!(relationResult &amp;&amp; relationResult['isDisabled']);\n\n        if ($.inArray(editType, notEditableTypeList) !== -1) {\n            isEditable = false;\n        } else {\n            isEditable = !(relationResult &amp;&amp; relationResult['isEditable'] === false);\n        }\n\n        return {\n            isEditable: isEditable,\n            isDisabled: isDisabled\n        };\n    },\n\n    /**\n     * rowKey 와 columnName 에 해당하는 셀이 편집 가능한지 여부를 반환한다.\n     * @param {String} columnName   컬럼명\n     * @returns {Boolean}    편집 가능한지 여부\n     */\n    isEditable: function(columnName) {\n        var notEditableTypeList = ['_number', 'normal'],\n            editType = this.columnModel.getEditType(columnName),\n            result = false;\n\n        if ($.inArray(editType, notEditableTypeList) === -1) {\n            result = this.getCellState(columnName).isEditable;\n        }\n        return result;\n    },\n\n    /**\n     * rowKey 와 columnName 에 해당하는 셀이 disable 상태인지 여부를 반환한다.\n     * @param {String} columnName   컬럼명\n     * @returns {Boolean}    disabled 처리를 할지 여부\n     */\n    isDisabled: function(columnName) {\n        var cellState;\n        cellState = this.getCellState(columnName);\n        return cellState.isDisabled;\n    },\n\n    /**\n     * getRowSpanData\n     * rowSpan 설정값을 반환한다.\n     * @param {String} [columnName] 인자가 존재하지 않을 경우, 행 전체의 rowSpanData 를 맵 형태로 반환한다.\n     * @returns {*|{count: number, isMainRow: boolean, mainRowKey: *}}   rowSpan 설정값\n     */\n    getRowSpanData: function(columnName) {\n        var isRowSpanEnable = this.collection.isRowSpanEnable(),\n            rowKey = this.get('rowKey');\n\n        return this.extraDataManager.getRowSpanData(columnName, rowKey, isRowSpanEnable);\n    },\n\n    /**\n     * rowSpanData를 설정한다.\n     * @param {string} columnName - 컬럼명\n     * @param {object} data - rowSpan 정보를 가진 객체\n     */\n    setRowSpanData: function(columnName, data) {\n        this.extraDataManager.setRowSpanData(columnName, data);\n        this._triggerExtraDataChangeEvent();\n    },\n\n    /**\n     * rowState 를 설정한다.\n     * @param {string} rowState 해당 행의 상태값. 'DISABLED|DISABLED_CHECK|CHECKED' 중 하나를 설정한다.\n     * @param {boolean} silent 내부 change 이벤트 발생 여부\n     */\n    setRowState: function(rowState, silent) {\n        this.extraDataManager.setRowState(rowState);\n        if (!silent) {\n            this._triggerExtraDataChangeEvent();\n        }\n    },\n\n    /**\n     * rowKey 와 columnName 에 해당하는 Cell 에 CSS className 을 설정한다.\n     * @param {String} columnName 컬럼 이름\n     * @param {String} className 지정할 디자인 클래스명\n     */\n    addCellClassName: function(columnName, className) {\n        this.extraDataManager.addCellClassName(columnName, className);\n        this._triggerExtraDataChangeEvent();\n    },\n\n    /**\n     * rowKey에 해당하는 행 전체에 CSS className 을 설정한다.\n     * @param {String} className 지정할 디자인 클래스명\n     */\n    addClassName: function(className) {\n        this.extraDataManager.addClassName(className);\n        this._triggerExtraDataChangeEvent();\n    },\n\n    /**\n     * rowKey 와 columnName 에 해당하는 Cell 에 CSS className 을 제거한다.\n     * @param {String} columnName 컬럼 이름\n     * @param {String} className 지정할 디자인 클래스명\n     */\n    removeCellClassName: function(columnName, className) {\n        this.extraDataManager.removeCellClassName(columnName, className);\n        this._triggerExtraDataChangeEvent();\n    },\n\n    /**\n     * rowKey 에 해당하는 행 전체에 CSS className 을 제거한다.\n     * @param {String} className 지정할 디자인 클래스명\n     */\n    removeClassName: function(className) {\n        this.extraDataManager.removeClassName(className);\n        this._triggerExtraDataChangeEvent();\n    },\n\n    /**\n     * html string 을 encoding 한다.\n     * columnModel 에 notUseHtmlEntity 가 설정된 경우는 동작하지 않는다.\n     *\n     * @param {String} columnName   컬럼명\n     * @returns {String} 인코딩된 결과값\n     */\n    getHTMLEncodedString: function(columnName) {\n        var columnModel = this.columnModel.getColumnModel(columnName),\n            isTextType = this.columnModel.isTextType(columnName),\n            value = this.get(columnName),\n            notUseHtmlEntity = columnModel.notUseHtmlEntity;\n        if (!notUseHtmlEntity &amp;&amp; isTextType &amp;&amp; tui.util.hasEncodableString(value)) {\n            value = tui.util.encodeHTMLEntity(value);\n        }\n        return value;\n    },\n\n    /**\n     * ctrl + c 로 복사 기능을 사용할 때 list 형태(select, button, checkbox)의 cell 의 경우, 해당 value 에 부합하는 text로 가공한다.\n     * List type 의 경우 데이터 값과 editOption.list 의 text 값이 다르기 때문에\n     * text 로 전환해서 반환할 때 처리를 하여 변환한다.\n     *\n     * @param {String} columnName   컬럼명\n     * @returns {String} text 형태로 가공된 문자열\n     * @private\n     */\n    _getListTypeVisibleText: function(columnName) {\n        var value = this.get(columnName),\n            columnModel = this.columnModel.getColumnModel(columnName),\n            resultOptionList, editOptionList, typeExpected, valueList;\n\n        if (tui.util.isExisty(tui.util.pick(columnModel, 'editOption', 'list'))) {\n            resultOptionList = this.getRelationResult(['optionListChange'])[columnName];\n            editOptionList = resultOptionList &amp;&amp; resultOptionList['optionList'] ?\n                    resultOptionList['optionList'] : columnModel.editOption.list;\n\n            typeExpected = typeof editOptionList[0].value;\n            valueList = value.toString().split(',');\n            if (typeExpected !== typeof valueList[0]) {\n                valueList = _.map(valueList, function(val) {\n                    return util.convertValueType(val, typeExpected);\n                });\n            }\n            _.each(valueList, function(val, index) {\n                var item = _.findWhere(editOptionList, {value: val});\n                valueList[index] = item &amp;&amp; item.text || '';\n            }, this);\n\n            return valueList.join(',');\n        }\n    },\n\n    /**\n     * change 이벤트 발생시 동일한 changed 객체의 public 프라퍼티가 동일한 경우 중복 처리를 막기 위해 사용한다.\n     * 10ms 내에 같은 객체로 함수 호출이 일어나면 true를 반환한다.\n     * @param {object} publicChanged 비교할 객체\n     * @returns {boolean} 중복이면 true, 아니면 false\n     */\n    isDuplicatedPublicChanged: function(publicChanged) {\n        if (this._timeoutIdForChanged &amp;&amp; _.isEqual(this._lastPublicChanged, publicChanged)) {\n            return true;\n        }\n        clearTimeout(this._timeoutIdForChanged);\n        this._timeoutIdForChanged = setTimeout(_.bind(function() {\n            this._timeoutIdForChanged = null;\n        }, this), 10);\n        this._lastPublicChanged = publicChanged;\n\n        return false;\n    },\n\n    /**\n     * 복사 기능을 사용할 때 화면에 보여지는 데이터를 반환한다.\n     * @param {String} columnName   컬럼명\n     * @returns {String} 화면에 보여지는 데이터로 가공된 문자열\n     */\n    getVisibleText: function(columnName) {\n        var columnModel = this.columnModel,\n            value = this.get(columnName),\n            editType, model,\n            listTypeMap = {\n                'select': true,\n                'radio': true,\n                'checkbox': true\n            };\n\n        if (columnModel) {\n            editType = columnModel.getEditType(columnName);\n            model = columnModel.getColumnModel(columnName);\n            //list type 의 editType 이 존재하는 경우\n            if (listTypeMap[editType]) {\n                if (tui.util.isExisty(tui.util.pick(model, 'editOption', 'list', 0, 'value'))) {\n                    value = this._getListTypeVisibleText(columnName);\n                } else {\n                    throw this.error('Check \"' + columnName + '\"\\'s editOption.list property out in your ColumnModel.');\n                }\n            } else if (_.isFunction(model.formatter)) {\n                //editType 이 없는 경우, formatter 가 있다면 formatter를 적용한다.\n                value = util.stripTags(model.formatter(this.getHTMLEncodedString(columnName), this.toJSON(), model));\n            }\n        }\n        value = !tui.util.isUndefined(value) ? value.toString() : value;\n        return value;\n    },\n\n    /**\n     * 컬럼모델에 정의된 relation 들을 수행한 결과를 반환한다. (기존 affectOption)\n     * @param {Array} callbackNameList 반환값의 결과를 확인할 대상 callbackList.\n     *        (default : ['optionListChange', 'isDisabled', 'isEditable'])\n     * @returns {{}|{columnName: {attribute: *}}} row 의 columnName 에 적용될 속성값.\n     */\n    getRelationResult: function(callbackNameList) {\n        var rowData = this.attributes,\n            relationListMap = this.columnModel.get('relationListMap'),\n            relationResult = {},\n            rowState = this.getRowState(),\n            callback, attribute, targetColumnList, value;\n\n        callbackNameList = (callbackNameList &amp;&amp; callbackNameList.length) ?\n            callbackNameList : ['optionListChange', 'isDisabled', 'isEditable'];\n\n        //columnModel 에 저장된 relationListMap 을 순회하며 데이터를 가져온다.\n        // relationListMap 구조 {columnName : relationList}\n        _.each(relationListMap, function(relationList, columnName) {\n            value = rowData[columnName];\n            //relationList 를 순회하며 수행한다.\n            _.each(relationList, function(relation) {\n                targetColumnList = relation.columnList;\n\n                //각 relation 에 걸려있는 콜백들을 수행한다.\n                _.each(callbackNameList, function(callbackName) {\n                    //isDisabled relation 의 경우 rowState 설정 값을 우선적으로 선택한다.\n                    if (!(rowState.isDisabled &amp;&amp; callbackName === 'isDisabled')) {\n                        callback = relation[callbackName];\n                        if (typeof callback === 'function') {\n                            attribute = '';\n                            if (callbackName === 'optionListChange') {\n                                attribute = 'optionList';\n                            } else if (callbackName === 'isDisabled') {\n                                attribute = 'isDisabled';\n                            } else if (callbackName === 'isEditable') {\n                                attribute = 'isEditable';\n                            }\n                            if (attribute) {\n                                //relation 에 걸려있는 컬럼들의 값을 변경한다.\n                                _.each(targetColumnList, function(targetColumnName) {\n                                    relationResult[targetColumnName] = relationResult[targetColumnName] || {};\n                                    relationResult[targetColumnName][attribute] = callback(value, rowData);\n                                }, this);\n                            }\n                        }\n                    }\n                }, this);\n            }, this);\n        }, this);\n        return relationResult;\n    }\n}, {\n    privateProperties: PRIVATE_PROPERTIES\n});\n\nmodule.exports = Row;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"