tui.util.defineNamespace("fedoc.content", {});
fedoc.content["painter_cell_text-convertible.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Painter class for the text-convertible cell\n * @author NHN Ent. FE Development Team\n */\n'use strict';\n\nvar Cell = require('../cell');\nvar TextCell = require('./text');\nvar util = require('../../common/util');\nvar formUtil = require('../../common/formUtil');\n\n/**\n * input 이 존재하지 않는 text 셀에서 편집시 input 이 존재하는 셀로 변환이 가능한 cell renderer\n * @module painter/cell/text-convertible\n * @extends module:painter/cell/text\n */\nvar ConvertibleCell = tui.util.defineClass(TextCell,/**@lends module:painter/cell/text-convertible.prototype */{\n    /**\n     * @constructs\n     */\n    init: function() {\n        TextCell.apply(this, arguments);\n        this.setOwnProperties({\n            timeoutIdForClick: 0,\n            editingCell: {\n                rowKey: null,\n                columnName: ''\n            },\n            clicked: {\n                rowKey: null,\n                columnName: null\n            }\n        });\n    },\n\n    redrawAttributes: ['isDisabled', 'isEditable', 'value'],\n\n    eventHandler: {\n        'dblclick': '_onDblClick',\n        'mousedown': '_onMouseDown',\n        'blur input': '_onBlurConvertible',\n        'keydown input': '_onKeyDown',\n        'focus input': '_onFocus',\n        'selectstart input': '_onSelectStart'\n    },\n\n    /**\n     * Content markup template\n     * @returns {string} html\n     */\n    contentTemplate: _.template(\n        '&lt;span class=\"input\">' +\n        '&lt;input' +\n        ' type=\"&lt;%=type%>\"' +\n        ' value=\"&lt;%=value%>\"' +\n        ' name=\"&lt;%=name%>\"' +\n        ' align=\"center\"' +\n        ' maxLength=\"&lt;%=maxLength%>\"' +\n        ' &lt;% if (isDisabled) print(\"disabled\") %>' +\n        '/>' +\n        '&lt;/span>'\n    ),\n\n    /**\n     * 자기 자신의 인스턴스의 editType 을 반환한다.\n     * @returns {String} editType 'normal|button|select|button|text|text-password|text-convertible'\n     */\n    getEditType: function() {\n        return 'text-convertible';\n    },\n\n    /**\n     * cell 에서 키보드 enter 를 입력했을 때 편집모드로 전환. cell 내 input 에 focus 를 수행하는 로직. 필요에 따라 override 한다.\n     * @param {jQuery} $td 해당 cell 엘리먼트\n     */\n    focusIn: function($td) {\n        this._startEdit($td);\n    },\n\n    /**\n     * focus in 상태에서 키보드 esc 를 입력했을 때 편집모드를 벗어난다. cell 내 input 을 blur 시키고, 편집모드를 벗어나는 로직.\n     * - 필요에 따라 override 한다.\n     */\n    focusOut: function() {\n        this.grid.focusModel.focusClipboard();\n    },\n\n    /**\n     * Cell data 를 인자로 받아 &lt;td> 안에 들아갈 html string 을 반환한다.\n     * redrawAttributes 에 해당하는 프로퍼티가 변경되었을 때 수행될 로직을 구현한다.\n     * @param {object} cellData 모델의 셀 데이터\n     * @returns {string} html 마크업 문자열\n     * @example\n     * var html = this.getContentHtml();\n     * &lt;select>\n     *     &lt;option value='1'>option1&lt;/option>\n     *     &lt;option value='2'>option1&lt;/option>\n     *     &lt;option value='3'>option1&lt;/option>\n     * &lt;/select>\n     */\n    getContentHtml: function(cellData) {\n        // FIXME: defaultValue 옵션값 처리 (cellData.value 를 참조하도록)\n        var columnModel = this.getColumnModel(cellData),\n            value = this.grid.dataModel.get(cellData.rowKey).getHTMLEncodedString(cellData.columnName);\n\n        if (tui.util.isUndefined(value)) {\n            value = '';\n        }\n\n        if (!this._isEditingCell(cellData)) {\n            if (tui.util.isFunction(columnModel.formatter)) {\n                value = columnModel.formatter(value, this.grid.dataModel.get(cellData.rowKey).attributes, columnModel);\n            }\n            return value;\n        }\n\n        return this.contentTemplate({\n            type: this._getInputType(),\n            value: value,\n            name: util.getUniqueKey(),\n            isDisabled: cellData.isDisabled,\n            maxLength: columnModel.editOption.maxLength\n        });\n    },\n\n    /**\n     * 각 셀 페인터 인스턴스마다 정의된 getContentHtml 을 이용하여\n     * 컬럼모델의 defaultValue, beforeText, afterText 를 적용한 content html 마크업 스트링 을 반환한다.\n     * (상태에 따라 Text나 Base의 함수를 선택해서 사용해야 하기 때문에, 추가로 override 해서 prototype을 이용해 실행)\n     * @param {object} cellData Model의 셀 데이터\n     * @returns {string} 컬럼모델의 defaultValue, beforeText, afterText 를 적용한 content html 마크업 스트링\n     * @private\n     * @override\n     */\n    _getContentHtml: function(cellData) {\n        var targetProto;\n\n        if (this._isEditingCell(cellData)) {\n            targetProto = TextCell.prototype;\n        } else {\n            targetProto = Cell.prototype;\n        }\n\n        return targetProto._getContentHtml.call(this, cellData);\n    },\n\n    /**\n     * 현재 편집중인 셀인지 여부를 반환한다.\n     * @param {object} cellData Model의 셀 데이터\n     * @returns {boolean} - 편집중이면 true, 아니면 false\n     * @private\n     */\n    _isEditingCell: function(cellData) {\n        var editingCell = this.editingCell;\n        return (editingCell.rowKey === cellData.rowKey.toString() &amp;&amp;\n            editingCell.columnName === cellData.columnName.toString());\n    },\n\n    /**\n     * model의 redrawAttributes 에 해당하지 않는 프로퍼티의 변화가 발생했을 때 수행할 메서드\n     * redrawAttributes 에 해당하지 않는 프로퍼티가 변경되었을 때 수행할 로직을 구현한다.\n     * @param {object} cellData 모델의 셀 데이터\n     * @param {jquery} $td 해당 cell 엘리먼트\n     * @param {Boolean} hasFocusedElement 해당 셀에 실제 focus 된 엘리먼트가 존재하는지 여부\n     */\n    setElementAttribute: function(cellData, $td, hasFocusedElement) {}, // eslint-disable-line no-unused-vars\n\n    /**\n     * blur 이벤트 핸들러\n     * @param {event} blurEvent 이벤트 객체\n     * @private\n     */\n    _onBlurConvertible: function(blurEvent) {\n        var $target = $(blurEvent.target),\n            $td = $target.closest('td'),\n            focusModel = this.grid.focusModel;\n\n        this._onBlur(blurEvent);\n        this._endEdit($td);\n        this._validateData(this.getRowKey($td), this.getColumnName($td));\n\n        _.defer(function() {\n            focusModel.refreshState();\n        });\n    },\n\n    /**\n     * text를 textbox 로 교체한다.\n     * @param {jQuery} $td 해당 cell 엘리먼트\n     * @private\n     */\n    _startEdit: function($td) {\n        var dataModel = this.grid.dataModel,\n            $input, rowKey, columnName, cellState;\n\n        this._blurEditingCell();\n\n        rowKey = this.getRowKey($td);\n        columnName = this.getColumnName($td);\n        cellState = dataModel.get(rowKey).getCellState(columnName);\n\n        if (cellState.isEditable &amp;&amp; !dataModel.isDisabled &amp;&amp; !cellState.isDisabled) {\n            this.editingCell = {\n                rowKey: rowKey,\n                columnName: columnName\n            };\n\n            this.redraw(this._getCellData($td), $td);\n            $input = $td.find('input');\n            this.originalText = $input.val();\n            formUtil.setCursorToEnd($input.get(0));\n            $input.select();\n        }\n    },\n\n    /**\n     * textbox를  text로 교체한다.\n     * @param {jQuery} $td 해당 cell 엘리먼트\n     * @private\n     */\n    _endEdit: function($td) {\n        var cellData = this._getCellData($td);\n        this.editingCell = {\n            rowKey: null,\n            columnName: null\n        };\n        this.clicked = {\n            rowKey: null,\n            columnName: null\n        };\n        if (cellData) {\n            this.redraw(cellData, $td);\n        }\n    },\n\n    /**\n     * Trigger blur event on editing cell if exist\n     * @private\n     */\n    _blurEditingCell: function() {\n        var rowKey = this.editingCell.rowKey,\n            columnName = this.editingCell.columnName,\n            $td;\n\n        if (!tui.util.isNull(rowKey) &amp;&amp; !tui.util.isNull(columnName)) {\n            $td = this.grid.dataModel.getElement(rowKey, columnName);\n            $td.find('input')[0].blur();\n        }\n    },\n\n    /**\n     * Event Handler for double click event.\n     * @param  {MouseEvent} mouseEvent - MouseEvent object\n     */\n    _onDblClick: function(mouseEvent) {\n        var $target = $(mouseEvent.target),\n            $td = $target.closest('td'),\n            address = this._getCellAddress($td);\n\n        if (!this._isEditingCell(address)) {\n            this._startEdit($td);\n        }\n    },\n\n    /**\n     * mousedown 이벤트 핸들러.\n     * containerView의 onMouseDown에서 focusClipboard를 호출하여 input에서 의도하지 않은 blur 이벤트가 발생하는 것을\n     * 방지하기 위해 이벤트 버블링을 멈춘다.\n     * @param {MouseEvent} event 마우스 이벤트 객체\n     * @private\n     */\n    _onMouseDown: function(event) {\n        if ($(event.target).is('input')) {\n            event.stopPropagation();\n        }\n    }\n});\n\nmodule.exports = ConvertibleCell;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"