tui.util.defineNamespace("fedoc.content", {});
fedoc.content["model_focus.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Focus 관련 데이터 처리름 담당한다.\n * @author NHN Ent. FE Development Team\n */\n'use strict';\n\nvar Model = require('../base/model'),\n    util = require('../common/util'),\n    GridEvent = require('../common/gridEvent');\n\n/**\n * Focus model\n * RowList collection 이 focus class 를 listen 한다.\n * @module model/focus\n * @extends module:base/model\n */\nvar Focus = Model.extend(/**@lends module:model/focus.prototype */{\n    /**\n     * @constructs\n     * @param {Object} attrs - Attributes\n     * @param {Object} options - Options\n     */\n    initialize: function(attrs, options) {\n        Model.prototype.initialize.apply(this, arguments);\n\n        this.dataModel = options.dataModel;\n        this.columnModel = options.columnModel;\n        this.dimensionModel = options.dimensionModel;\n        this.renderModel = options.renderModel;\n        this.cellFactory = options.cellFactory;\n        this.domState = options.domState;\n\n        this.listenTo(this.dataModel, 'add', this._onAddData);\n        this.listenTo(this.dataModel, 'reset', this._onResetData);\n    },\n\n    defaults: {\n        rowKey: null,\n        columnName: '',\n        prevRowKey: null,\n        prevColumnName: ''\n    },\n\n    /**\n     * Event handler for 'add' event on dataModel.\n     * @param  {Array.&lt;module:model/data/row>} rows - New appended row model\n     * @param  {Object} options - Options. See {@link module:model/data/row#append}\n     * @private\n     */\n    _onAddData: function(rows, options) {\n        if (options.focus) {\n            this.focusAt(options.at, 0);\n        }\n    },\n\n    /**\n     * Event handler for 'reset' event on dataModel.\n     * @private\n     */\n    _onResetData: function() {\n        this.unselect(true);\n    },\n\n    /**\n     * Saves previous data.\n     * @private\n     */\n    _savePrevious: function() {\n        if (this.get('rowKey') !== null) {\n            this.set('prevRowKey', this.get('rowKey'));\n        }\n        if (this.get('columnName')) {\n            this.set('prevColumnName', this.get('columnName'));\n        }\n    },\n\n    /**\n     * Clear previous data.\n     * @private\n     */\n    _clearPrevious: function() {\n        this.set({\n            prevRowKey: null,\n            prevColumnName: ''\n        });\n    },\n\n    /**\n     * Returns whether given rowKey is equal to current value\n     * @param  {(Number|String)} rowKey - Row key\n     * @returns {Boolean} - True if equal\n     */\n    _isCurrentRow: function(rowKey) {\n        // compare with == operator to avoid strict comparision\n        // (rowkey can be a number or a string)\n        return this.get('rowKey') == rowKey; // eslint-disable-line eqeqeq\n    },\n\n    /**\n     * Returns whether given rowKey and columnName is equal to current value\n     * @param  {(Number|String)} rowKey - Row key\n     * @param  {String} columnName - Column name\n     * @returns {Boolean} - True if equal\n     */\n    _isCurrentCell: function(rowKey, columnName) {\n        return this._isCurrentRow(rowKey) &amp;&amp; this.get('columnName') === columnName;\n    },\n\n    /**\n     * Selects the given row\n     * @param {Number|String} rowKey - Rowkey of the target row\n     * @returns {Boolean} True is success\n     */\n    select: function(rowKey) {\n        var eventData = new GridEvent(),\n            currentRowKey = this.get('rowKey');\n\n        if (this._isCurrentRow(rowKey)) {\n            return true;\n        }\n\n        eventData.setData({\n            rowKey: rowKey,\n            prevRowKey: currentRowKey,\n            rowData: this.dataModel.getRowData(rowKey)\n        });\n        this.trigger('select', eventData);\n        if (eventData.isStopped()) {\n            this._cancelSelect();\n            return false;\n        }\n\n        this.set('rowKey', rowKey);\n        if (this.columnModel.get('selectType') === 'radio') {\n            this.dataModel.check(rowKey);\n        }\n        return true;\n    },\n\n    /**\n     * Cancel select\n     * @private\n     */\n    _cancelSelect: function() {\n        var prevColumnName = this.get('prevColumnName');\n        this.set('columnName', prevColumnName);\n        this.trigger('focus', this.get('rowKey'), prevColumnName);\n    },\n\n    /**\n     * 행을 unselect 한다.\n     * @param {boolean} blur - The boolean value whether to invoke blur\n     */\n    unselect: function(blur) {\n        if (blur) {\n            this.blur();\n        }\n        this.set({\n            rowKey: null\n        });\n    },\n\n    /**\n     * Focus to the cell identified by given rowKey and columnName.\n     * @param {Number|String} rowKey - rowKey\n     * @param {String} columnName - columnName\n     * @param {Boolean} isScrollable - if set to true, move scroll position to focused position\n     * @returns {Boolean} true if focused cell is changed\n     */\n    focus: function(rowKey, columnName, isScrollable) {\n        if (!this._isValidCell(rowKey, columnName) ||\n            this.columnModel.isMetaColumn(columnName) ||\n            this._isCurrentCell(rowKey, columnName)) {\n            return true;\n        }\n\n        this.blur();\n        if (!this.select(rowKey)) {\n            return false;\n        }\n\n        this.set('columnName', columnName);\n        this.trigger('focus', rowKey, columnName);\n        if (isScrollable) {\n            this.scrollToFocus();\n        }\n        return true;\n    },\n\n    /**\n     * Focus to the cell identified by given rowIndex and columnIndex.\n     * @param {(Number|String)} rowIndex - rowIndex\n     * @param {String} columnIndex - columnIndex\n     * @param {boolean} [isScrollable=false] - if set to true, scroll to focused cell\n     * @returns {Boolean} true if success\n     */\n    focusAt: function(rowIndex, columnIndex, isScrollable) {\n        var row = this.dataModel.at(rowIndex),\n            column = this.columnModel.at(columnIndex, true),\n            result = false;\n        if (row &amp;&amp; column) {\n            result = this.focus(row.get('rowKey'), column['columnName'], isScrollable);\n        }\n        return result;\n    },\n\n    /**\n     * Focus to the cell identified by given rowKey and columnName and change it to edit-mode if editable.\n     * @param {(Number|String)} rowKey - rowKey\n     * @param {String} columnName - columnName\n     * @param {boolean} [isScrollable=false] - if set to true, scroll to focused cell\n     * @returns {Boolean} true if success\n     */\n    focusIn: function(rowKey, columnName, isScrollable) {\n        var result = this.focus(rowKey, columnName, isScrollable);\n        if (result) {\n            rowKey = this.dataModel.getMainRowKey(rowKey, columnName);\n            if (this.dataModel.get(rowKey).isEditable(columnName)) {\n                this.trigger('focusIn', rowKey, columnName);\n            } else {\n                this.focusClipboard();\n            }\n        }\n        return result;\n    },\n\n    /**\n     * Focus to the cell identified by given rowIndex and columnIndex and change it to edit-mode if editable.\n     * @param {(Number|String)} rowIndex - rowIndex\n     * @param {String} columnIndex - columnIndex\n     * @param {Boolean} [isScrollable=false] - if set to true, scroll to focused cell\n     * @returns {Boolean} true if success\n     */\n    focusInAt: function(rowIndex, columnIndex, isScrollable) {\n        var row = this.dataModel.at(rowIndex),\n            column = this.columnModel.at(columnIndex, true),\n            result = false;\n\n        if (row &amp;&amp; column) {\n            result = this.focusIn(row.get('rowKey'), column['columnName'], isScrollable);\n        }\n        return result;\n    },\n\n    /**\n     * clipboard 에 focus 한다.\n     */\n    focusClipboard: function() {\n        this.trigger('focusClipboard');\n    },\n\n    /**\n     * If the grid has focused element, make sure that focusModel has a valid data,\n     * Otherwise call focusModel.blur().\n     */\n    refreshState: function() {\n        if (!this.domState.hasFocusedElement()) {\n            this.blur();\n        } else if (!this.has() &amp;&amp; !this.restore()) {\n            this.focusAt(0, 0);\n        }\n    },\n\n    /**\n     * Scroll to focus\n     */\n    scrollToFocus: function() {\n        var rowKey = this.get('rowKey'),\n            columnName = this.get('columnName'),\n            scrollPosition = this.dimensionModel.getScrollPosition(rowKey, columnName);\n\n        if (!tui.util.isEmpty(scrollPosition)) {\n            this.renderModel.set(scrollPosition);\n        }\n    },\n\n    /**\n     * 디자인 blur 처리한다.\n     * @returns {Model.Focus} This object\n     */\n    blur: function() {\n        if (this.has()) {\n            this._savePrevious();\n            this.trigger('blur', this.get('rowKey'), this.get('columnName'));\n            if (this.get('rowKey') !== null) {\n                this.set('columnName', '');\n            }\n        }\n        return this;\n    },\n\n    /**\n     * 현재 focus 정보를 반환한다.\n     * @returns {{rowKey: (number|string), columnName: string}} 현재 focus 정보에 해당하는 rowKey, columnName\n     */\n    which: function() {\n        return {\n            rowKey: this.get('rowKey'),\n            columnName: this.get('columnName')\n        };\n    },\n\n    /**\n     * 현재 focus 정보를 index 기준으로 반환한다.\n     * @param {boolean} isPrevious 이전 focus 정보를 반환할지 여부\n     * @returns {{row: number, column: number}} The object that contains index info\n     */\n    indexOf: function(isPrevious) {\n        var rowKey = isPrevious ? this.get('prevRowKey') : this.get('rowKey'),\n            columnName = isPrevious ? this.get('prevColumnName') : this.get('columnName');\n\n        return {\n            row: this.dataModel.indexOfRowKey(rowKey),\n            column: this.columnModel.indexOfColumnName(columnName, true)\n        };\n    },\n\n    /**\n     * Returns whether has focus.\n     * @returns {boolean} True if has focus.\n     */\n    has: function() {\n        return this._isValidCell(this.get('rowKey'), this.get('columnName'));\n    },\n\n    /**\n     * Restore previous focus data.\n     * @returns {boolean} True if restored\n     */\n    restore: function() {\n        var prevRowKey = this.get('prevRowKey'),\n            prevColumnName = this.get('prevColumnName'),\n            restored = false;\n\n        if (this._isValidCell(prevRowKey, prevColumnName)) {\n            this.focus(prevRowKey, prevColumnName);\n            restored = true;\n        }\n        return restored;\n    },\n\n    /**\n     * Returns whether the specified cell is exist\n     * @param {String|Number} rowKey - Rowkey\n     * @param {String} columnName - ColumnName\n     * @returns {boolean} True if exist\n     */\n    _isValidCell: function(rowKey, columnName) {\n        var isValidRowKey = !util.isBlank(rowKey) &amp;&amp; !!this.dataModel.get(rowKey),\n            isValidColumnName = !util.isBlank(columnName) &amp;&amp; !!this.columnModel.getColumnModel(columnName);\n\n        return isValidRowKey &amp;&amp; isValidColumnName;\n    },\n\n    /**\n     * 현재 focus 된 row 기준으로 offset 만큼 이동한 rowKey 를 반환한다.\n     * @param {Number} offset   이동할 offset\n     * @returns {Number|String} rowKey   offset 만큼 이동한 위치의 rowKey\n     * @private\n     */\n    _findRowKey: function(offset) {\n        var index, row,\n            dataModel = this.dataModel;\n        if (this.has()) {\n            index = Math.max(\n                Math.min(\n                    dataModel.indexOfRowKey(this.get('rowKey')) + offset,\n                    this.dataModel.length - 1\n                ), 0\n            );\n            row = dataModel.at(index);\n            return row &amp;&amp; row.get('rowKey');\n        }\n    },\n\n    /**\n     * 현재 focus 된 column 기준으로 offset 만큼 이동한 columnName 을 반환한다.\n     * @param {Number} offset   이동할 offset\n     * @returns {String} columnName  offset 만큼 이동한 위치의 columnName\n     * @private\n     */\n    _findColumnName: function(offset) {\n        var index,\n            columnModel = this.columnModel,\n            columnModelList = columnModel.getVisibleColumnModelList(),\n            columnIndex = columnModel.indexOfColumnName(this.get('columnName'), true);\n\n        if (this.has()) {\n            index = Math.max(Math.min(columnIndex + offset, columnModelList.length - 1), 0);\n            return columnModelList[index] &amp;&amp; columnModelList[index]['columnName'];\n        }\n    },\n\n    /**\n     * rowSpanData 를 반환한다.\n     * @param {Number|String} rowKey    조회할 데이터의 키값\n     * @param {String} columnName   컬럼명\n     * @returns {*|{count: number, isMainRow: boolean, mainRowKey: *}|*} rowSpanData 정보\n     * @private\n     */\n    _getRowSpanData: function(rowKey, columnName) {\n        return this.dataModel.get(rowKey).getRowSpanData(columnName);\n    },\n\n    /**\n     * offset 만큼 뒤로 이동한 row 의 index 를 반환한다.\n     * @param {number} offset   이동할 offset\n     * @returns {Number} 이동한 위치의 row index\n     */\n    nextRowIndex: function(offset) {\n        var rowKey = this.nextRowKey(offset);\n        return this.dataModel.indexOfRowKey(rowKey);\n    },\n\n    /**\n     * offset 만큼 앞으로 이동한 row의 index를 반환한다.\n     * @param {number} offset 이동할 offset\n     * @returns {Number} 이동한 위치의 row index\n     */\n    prevRowIndex: function(offset) {\n        var rowKey = this.prevRowKey(offset);\n        return this.dataModel.indexOfRowKey(rowKey);\n    },\n\n    /**\n     * 다음 컬럼의 인덱스를 반환한다.\n     * @returns {Number} 다음 컬럼의 index\n     */\n    nextColumnIndex: function() {\n        var columnName = this.nextColumnName();\n        return this.columnModel.indexOfColumnName(columnName, true);\n    },\n\n    /**\n     * 이전 컬럼의 인덱스를 반환한다.\n     * @returns {Number} 이전 컬럼의 인덱스\n     */\n    prevColumnIndex: function() {\n        var columnName = this.prevColumnName();\n        return this.columnModel.indexOfColumnName(columnName, true);\n    },\n\n    /**\n     * keyEvent 발생 시 호출될 메서드로,\n     * rowSpan 정보 까지 계산된 다음 rowKey 를 반환한다.\n     * @param {number}  offset 이동할 offset\n     * @returns {Number|String} offset 만큼 이동한 위치의 rowKey\n     */\n    nextRowKey: function(offset) {\n        var focused = this.which(),\n            rowKey = focused.rowKey,\n            count, rowSpanData;\n\n        offset = (typeof offset === 'number') ? offset : 1;\n        if (offset > 1) {\n            rowKey = this._findRowKey(offset);\n            rowSpanData = this._getRowSpanData(rowKey, focused.columnName);\n            if (!rowSpanData.isMainRow) {\n                rowKey = this._findRowKey(rowSpanData.count + offset);\n            }\n        } else {\n            rowSpanData = this._getRowSpanData(rowKey, focused.columnName);\n            if (rowSpanData.isMainRow &amp;&amp; rowSpanData.count > 0) {\n                rowKey = this._findRowKey(rowSpanData.count);\n            } else if (!rowSpanData.isMainRow) {\n                count = rowSpanData.count;\n                rowSpanData = this._getRowSpanData(rowSpanData.mainRowKey, focused.columnName);\n                rowKey = this._findRowKey(rowSpanData.count + count);\n            } else {\n                rowKey = this._findRowKey(1);\n            }\n        }\n        return rowKey;\n    },\n\n    /**\n     * keyEvent 발생 시 호출될 메서드로,\n     * rowSpan 정보 까지 계산된 이전 rowKey 를 반환한다.\n     * @param {number}  offset 이동할 offset\n     * @returns {Number|String} offset 만큼 이동한 위치의 rowKey\n     */\n    prevRowKey: function(offset) {\n        var focused = this.which(),\n            rowKey = focused.rowKey,\n            rowSpanData;\n        offset = typeof offset === 'number' ? offset : 1;\n        offset *= -1;\n\n        if (offset &lt; -1) {\n            rowKey = this._findRowKey(offset);\n            rowSpanData = this._getRowSpanData(rowKey, focused.columnName);\n            if (!rowSpanData.isMainRow) {\n                rowKey = this._findRowKey(rowSpanData.count + offset);\n            }\n        } else {\n            rowSpanData = this._getRowSpanData(rowKey, focused.columnName);\n            if (!rowSpanData.isMainRow) {\n                rowKey = this._findRowKey(rowSpanData.count - 1);\n            } else {\n                rowKey = this._findRowKey(-1);\n            }\n        }\n        return rowKey;\n    },\n\n    /**\n     * keyEvent 발생 시 호출될 메서드로, 다음 columnName 을 반환한다.\n     * @returns {String} 다음 컬럼명\n     */\n    nextColumnName: function() {\n        return this._findColumnName(1);\n    },\n\n    /**\n     * keyEvent 발생 시 호출될 메서드로, 이전 columnName 을 반환한다.\n     * @returns {String} 이전 컬럼명\n     */\n    prevColumnName: function() {\n        return this._findColumnName(-1);\n    },\n\n    /**\n     * 첫번째 row 의 key 를 반환한다.\n     * @returns {(string|number)} 첫번째 row 의 키값\n     */\n    firstRowKey: function() {\n        return this.dataModel.at(0).get('rowKey');\n    },\n\n    /**\n     * 마지막 row의 key 를 반환한다.\n     * @returns {(string|number)} 마지막 row 의 키값\n     */\n    lastRowKey: function() {\n        return this.dataModel.at(this.dataModel.length - 1).get('rowKey');\n    },\n\n    /**\n     * 첫번째 columnName 을 반환한다.\n     * @returns {string} 첫번째 컬럼명\n     */\n    firstColumnName: function() {\n        var columnModelList = this.columnModel.getVisibleColumnModelList();\n        return columnModelList[0]['columnName'];\n    },\n\n    /**\n     * 마지막 columnName 을 반환한다.\n     * @returns {string} 마지막 컬럼명\n     */\n    lastColumnName: function() {\n        var columnModelList = this.columnModel.getVisibleColumnModelList(),\n            lastIndex = columnModelList.length - 1;\n        return columnModelList[lastIndex]['columnName'];\n    }\n});\n\nmodule.exports = Focus;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"