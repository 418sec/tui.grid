tui.util.defineNamespace("fedoc.content", {});
fedoc.content["model_selection.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Selection Model class\n * @author NHN Ent. FE Development Team\n */\n'use strict';\n\nvar _ = require('underscore');\n\nvar Model = require('../base/model');\nvar util = require('../common/util');\nvar typeConstMap = require('../common/constMap').selectionType;\n\n/**\n * Selection Model class\n * @module model/selection\n * @extends module:base/view\n */\nvar Selection = Model.extend(/**@lends module:model/selection.prototype */{\n    /**\n     * @constructs\n     * @param {Object} attr - Attributes\n     * @param {Object} options - Options\n     */\n    initialize: function(attr, options) {\n        Model.prototype.initialize.apply(this, arguments);\n\n        this.setOwnProperties({\n            dataModel: options.dataModel,\n            columnModel: options.columnModel,\n            dimensionModel: options.dimensionModel,\n            focusModel: options.focusModel,\n            renderModel: options.renderModel,\n\n            inputRange: null,\n            intervalIdForAutoScroll: null,\n            scrollPixelScale: 40,\n            enabled: true,\n            selectionType: typeConstMap.CELL\n        });\n\n        this.listenTo(this.dataModel, 'add remove sort reset', this.end);\n        this.listenTo(this.dataModel, 'paste', this._onPasteData);\n    },\n\n    defaults: {\n        /**\n         * Selection range\n         * ex) {row: [0, 1], column: [1, 2]}\n         * @type {{row: array, column: array}}\n         */\n        range: null\n    },\n\n    /**\n     * Event handler for 'paste' event on DataModel\n     * @param {Object} range - Range\n     */\n    _onPasteData: function(range) {\n        this.start(range.startIdx.row, range.startIdx.column);\n        this.update(range.endIdx.row, range.endIdx.column);\n    },\n\n    /**\n     * Set selection type\n     * @param {string} type - Selection type (CELL, ROW, COLUMN)\n     */\n    setType: function(type) {\n        this.selectionType = typeConstMap[type] || this.selectionType;\n    },\n\n    /**\n     * Return the selection type\n     * @returns {string} type - Selection type (CELL, ROW, COLUMN)\n     */\n    getType: function() {\n        return this.selectionType;\n    },\n\n    /**\n     * Enables the selection.\n     */\n    enable: function() {\n        this.enabled = true;\n    },\n\n    /**\n     * Disables the selection.\n     */\n    disable: function() {\n        this.end();\n        this.enabled = false;\n    },\n\n    /**\n     * Returns whether the selection is enabled.\n     * @returns {boolean} True if the selection is enabled.\n     */\n    isEnabled: function() {\n        return this.enabled;\n    },\n\n    /**\n     * Starts the selection.\n     * @param {Number} rowIndex - Row index\n     * @param {Number} columnIndex - Column index\n     * @param {string} type - Selection type\n     */\n    start: function(rowIndex, columnIndex, type) {\n        if (!this.isEnabled()) {\n            return;\n        }\n\n        this.setType(type);\n        this.inputRange = {\n            row: [rowIndex, rowIndex],\n            column: [columnIndex, columnIndex]\n        };\n        this._resetRangeAttribute();\n    },\n\n    /**\n     * Starts the selection by mouse position.\n     * @param {number} pageX - X position relative to the document\n     * @param {number} pageY - Y position relative to the document\n     * @param {string} type - Selection type\n     */\n    startByMousePosition: function(pageX, pageY, type) {\n        var index = this.dimensionModel.getIndexFromMousePosition(pageX, pageY);\n        this.start(index.row, index.column, type);\n    },\n\n    /**\n     * Updates the selection range.\n     * @param {number} rowIndex - Row index\n     * @param {number} columnIndex - Column index\n     * @param {string} [type] - Selection type\n     */\n    update: function(rowIndex, columnIndex, type) {\n        var focusedIndex;\n\n        if (!this.enabled || rowIndex &lt; 0 || columnIndex &lt; 0) {\n            return;\n        }\n\n        if (!this.hasSelection()) {\n            focusedIndex = this.focusModel.indexOf();\n            this.start(focusedIndex.row, focusedIndex.column, type);\n        } else {\n            this.setType(type);\n        }\n\n        this._updateInputRange(rowIndex, columnIndex);\n        this._resetRangeAttribute();\n    },\n\n    /**\n     * Update input range (end range, not start range)\n     * @param {number} rowIndex - Row index\n     * @param {number} columnIndex - Column index\n     * @private\n     */\n    _updateInputRange: function(rowIndex, columnIndex) {\n        var inputRange = this.inputRange;\n\n        if (this.selectionType === typeConstMap.ROW) {\n            columnIndex = this.columnModel.getVisibleColumnModelList().length - 1;\n        } else if (this.selectionType === typeConstMap.COLUMN) {\n            rowIndex = this.dataModel.length - 1;\n        }\n\n        inputRange.row[1] = rowIndex;\n        inputRange.column[1] = columnIndex;\n    },\n\n    /**\n     * Extend column selection\n     * @param {undefined|Array} columnIndexes - Column indexes\n     * @param {number} pageX - Mouse position X\n     * @param {number} pageY - Mouse positino Y\n     */\n    extendColumnSelection: function(columnIndexes, pageX, pageY) {\n        var minimumColumnRange = this._minimumColumnRange;\n        var index = this.dimensionModel.getIndexFromMousePosition(pageX, pageY);\n        var range = {\n            row: [0, this.dataModel.length - 1],\n            column: []\n        };\n        var minMax;\n\n        if (!columnIndexes || !columnIndexes.length) {\n            columnIndexes = [index.column];\n        }\n\n        this._setScrolling(pageX, pageY);\n        if (minimumColumnRange) {\n            minMax = util.getMinMax(columnIndexes.concat(minimumColumnRange));\n        } else {\n            columnIndexes.push(this.inputRange.column[0]);\n            minMax = util.getMinMax(columnIndexes);\n        }\n        range.column.push(minMax.min, minMax.max);\n        this._resetRangeAttribute(range);\n    },\n\n    /**\n     * Set auto scrolling for selection\n     * @param {number} pageX - Mouse position X\n     * @param {number} pageY - Mouse positino Y\n     * @private\n     */\n    _setScrolling: function(pageX, pageY) {\n        var overflow = this.dimensionModel.getOverflowFromMousePosition(pageX, pageY);\n\n        this.stopAutoScroll();\n        if (this._isAutoScrollable(overflow.x, overflow.y)) {\n            this.intervalIdForAutoScroll = setInterval(\n                _.bind(this._adjustScroll, this, overflow.x, overflow.y)\n            );\n        }\n    },\n\n    /**\n     * Updates the selection range by mouse position.\n     * @param {number} pageX - X position relative to the document\n     * @param {number} pageY - Y position relative to the document\n     * @param {string} [type] - Selection type\n     */\n    updateByMousePosition: function(pageX, pageY, type) {\n        var index = this.dimensionModel.getIndexFromMousePosition(pageX, pageY);\n\n        this._setScrolling(pageX, pageY);\n        this.update(index.row, index.column, type);\n    },\n\n    /**\n     * selection 영역 선택을 종료하고 selection 데이터를 초기화한다.\n     */\n    end: function() {\n        this.inputRange = null;\n        this.unset('range');\n        this.unsetMinimumColumnRange();\n    },\n\n    /**\n     * Stops the auto-scroll interval.\n     */\n    stopAutoScroll: function() {\n        if (!_.isNull(this.intervalIdForAutoScroll)) {\n            clearInterval(this.intervalIdForAutoScroll);\n            this.intervalIdForAutoScroll = null;\n        }\n    },\n\n    /**\n     * Select all data in a row\n     * @param {Number} rowIndex - Row idnex\n     */\n    selectRow: function(rowIndex) {\n        if (this.isEnabled()) {\n            this.focusModel.focusAt(rowIndex, 0);\n            this.start(rowIndex, 0, typeConstMap.ROW);\n            this.update(rowIndex, this.columnModel.getVisibleColumnModelList().length - 1);\n        }\n    },\n\n    /**\n     * Select all data in a column\n     * @param {Number} columnIdx - Column index\n     */\n    selectColumn: function(columnIdx) {\n        if (this.isEnabled()) {\n            this.focusModel.focusAt(0, columnIdx);\n            this.start(0, columnIdx, typeConstMap.COLUMN);\n            this.update(this.dataModel.length - 1, columnIdx);\n        }\n    },\n\n    /**\n     * Selects all data range.\n     */\n    selectAll: function() {\n        if (this.isEnabled()) {\n            this.start(0, 0, typeConstMap.CELL);\n            this.update(this.dataModel.length - 1, this.columnModel.getVisibleColumnModelList().length - 1);\n        }\n    },\n\n    /**\n     * Returns the row and column indexes of the starting position.\n     * @returns {{row: number, column: number}} Objects containing indexes\n     */\n    getStartIndex: function() {\n        var range = this.get('range');\n\n        return {\n            row: range.row[0],\n            column: range.column[0]\n        };\n    },\n\n    /**\n     * Returns the row and column indexes of the ending position.\n     * @returns {{row: number, column: number}} Objects containing indexes\n     */\n    getEndIndex: function() {\n        var range = this.get('range');\n\n        return {\n            row: range.row[1],\n            column: range.column[1]\n        };\n    },\n\n    /**\n     * selection 데이터가 존재하는지 확인한다.\n     * @returns {boolean} selection 데이터 존재여부\n     */\n    hasSelection: function() {\n        return !!this.get('range');\n    },\n\n    /**\n     * Returns whether given range is a single cell. (include merged cell)\n     * @param {Array.&lt;String>} columnNameList - columnNameList\n     * @param {Array.&lt;Object>} rowList - rowList\n     * @returns {Boolean}\n     */\n    _isSingleCell: function(columnNameList, rowList) {\n        var isSingleColumn = columnNameList.length === 1;\n        var isSingleRow = rowList.length === 1;\n        var isSingleMergedCell = isSingleColumn &amp;&amp; !isSingleRow &amp;&amp;\n            (rowList[0].getRowSpanData(columnNameList[0]).count === rowList.length);\n\n        return (isSingleColumn &amp;&amp; isSingleRow) || isSingleMergedCell;\n    },\n\n    /**\n     * Returns the string value of all cells in the selection range as a single string.\n     * @param {Boolean} useFormattedValue - Whether using rendered value or data value\n     * @returns {String}\n     */\n    getValuesToString: function(useFormattedValue) {\n        var range = this.get('range');\n        var renderModel = this.renderModel;\n        var rowList = this.dataModel.slice(range.row[0], range.row[1] + 1);\n        var columnModelList = this.columnModel.getVisibleColumnModelList().slice(range.column[0], range.column[1] + 1);\n        var columnNames = _.pluck(columnModelList, 'columnName');\n        var rowValues = _.map(rowList, function(row) {\n            return _.map(columnNames, function(columnName) {\n                if (useFormattedValue) {\n                    return renderModel.getCellData(row.get('rowKey'), columnName).formattedValue;\n                }\n                return row.getValueString(columnName);\n            }).join('\\t');\n        });\n\n        if (this._isSingleCell(columnNames, rowList)) {\n            return rowValues[0];\n        }\n        return rowValues.join('\\n');\n    },\n\n    /**\n     * 마우스 드래그로 selection 선택 시 auto scroll 조건에 해당하는지 반환한다.\n     * @param {Number} overflowX    가로축 기준 영역 overflow 값\n     * @param {Number} overflowY    세로축 기준 영역 overflow 값\n     * @returns {boolean} overflow 되었는지 여부\n     * @private\n     */\n    _isAutoScrollable: function(overflowX, overflowY) {\n        return !(overflowX === 0 &amp;&amp; overflowY === 0);\n    },\n\n    /**\n     * Adjusts scrollTop and scrollLeft value.\n     * @param {Number} overflowX    가로축 기준 영역 overflow 값\n     * @param {Number} overflowY    세로축 기준 영역 overflow 값\n     * @private\n     */\n    _adjustScroll: function(overflowX, overflowY) {\n        var renderModel = this.renderModel;\n\n        if (overflowX) {\n            this._adjustScrollLeft(overflowX, renderModel.get('scrollLeft'), renderModel.get('maxScrollLeft'));\n        }\n        if (overflowY) {\n            this._adjustScrollTop(overflowY, renderModel.get('scrollTop'), renderModel.get('maxScrollTop'));\n        }\n    },\n\n    /**\n     * Adjusts scrollLeft value.\n     * @param  {number} overflowX - 1 | 0 | -1\n     * @param  {number} scrollLeft - Current scrollLeft value\n     * @param  {number} maxScrollLeft - Max scrollLeft value\n     * @private\n     */\n    _adjustScrollLeft: function(overflowX, scrollLeft, maxScrollLeft) {\n        var adjusted = scrollLeft;\n        var pixelScale = this.scrollPixelScale;\n\n        if (overflowX &lt; 0) {\n            adjusted = Math.max(0, scrollLeft - pixelScale);\n        } else if (overflowX > 0) {\n            adjusted = Math.min(maxScrollLeft, scrollLeft + pixelScale);\n        }\n        this.renderModel.set('scrollLeft', adjusted);\n    },\n\n    /**\n     * Adjusts scrollTop value.\n     * @param  {number} overflowY - 1 | 0 | -1\n     * @param  {number} scrollTop - Current scrollTop value\n     * @param  {number} maxScrollTop - Max scrollTop value\n     * @private\n     */\n    _adjustScrollTop: function(overflowY, scrollTop, maxScrollTop) {\n        var adjusted = scrollTop;\n        var pixelScale = this.scrollPixelScale;\n\n        if (overflowY &lt; 0) {\n            adjusted = Math.max(0, scrollTop - pixelScale);\n        } else if (overflowY > 0) {\n            adjusted = Math.min(maxScrollTop, scrollTop + pixelScale);\n        }\n        this.renderModel.set('scrollTop', adjusted);\n    },\n\n    /**\n     * Expands the 'this.inputRange' if rowspan data exists, and resets the 'range' attributes to the value.\n     * @param {{column: number[], row: number[]}} [inputRange] - Input range. Default is this.inputRange\n     * @private\n     */\n    _resetRangeAttribute: function(inputRange) {\n        var dataModel = this.dataModel;\n        var hasSpannedRange, spannedRange, tmpRowRange;\n\n        inputRange = inputRange || this.inputRange;\n        if (!inputRange) {\n            this.set('range', null);\n            return;\n        }\n\n        spannedRange = {\n            row: _.sortBy(inputRange.row),\n            column: _.sortBy(inputRange.column)\n        };\n\n        if (dataModel.isRowSpanEnable() &amp;&amp; this.selectionType === typeConstMap.CELL) {\n            do {\n                tmpRowRange = _.assign([], spannedRange.row);\n                spannedRange = this._getRowSpannedIndex(spannedRange);\n\n                hasSpannedRange = (\n                    spannedRange.row[0] !== tmpRowRange[0] ||\n                    spannedRange.row[1] !== tmpRowRange[1]\n                );\n            } while (hasSpannedRange);\n            this._setRangeMinMax(spannedRange.row, spannedRange.column);\n        }\n\n        this.set('range', spannedRange);\n    },\n\n    /**\n     * Set minimum column range\n     * @param {Array} range - Minimum column range\n     */\n    setMinimumColumnRange: function(range) {\n        this._minimumColumnRange = _.extend(range);\n    },\n\n    /**\n     * Unset minimum column range\n     */\n    unsetMinimumColumnRange: function() {\n        this._minimumColumnRange = null;\n    },\n\n    /**\n     * Set min, max value of range(row, column)\n     * @param {Array} rowRange - Row range\n     * @param {Array} columnRange - Column range\n     * @private\n     */\n    _setRangeMinMax: function(rowRange, columnRange) {\n        if (rowRange) {\n            rowRange[0] = Math.max(0, rowRange[0]);\n            rowRange[1] = Math.min(this.dataModel.length - 1, rowRange[1]);\n        }\n\n        if (columnRange) {\n            columnRange[0] = Math.max(0, columnRange[0]);\n            columnRange[1] = Math.min(this.columnModel.getVisibleColumnModelList().length - 1, columnRange[1]);\n        }\n    },\n\n    /**\n     * row start index 기준으로 rowspan 을 확인하며 startRangeList 업데이트 하는 함수\n     * @param {object} param - parameters\n     * @private\n     */\n    _concatRowSpanIndexFromStart: function(param) {\n        var startIndex = param.startIndex;\n        var endIndex = param.endIndex;\n        var columnName = param.columnName;\n        var rowSpanData = param.startRowSpanDataMap &amp;&amp; param.startRowSpanDataMap[columnName];\n        var startIndexList = param.startIndexList;\n        var endIndexList = param.endIndexList;\n        var spannedIndex;\n\n        if (!rowSpanData) {\n            return;\n        }\n\n        if (!rowSpanData.isMainRow) {\n            spannedIndex = startIndex + rowSpanData.count;\n            startIndexList.push(spannedIndex);\n        } else {\n            spannedIndex = startIndex + rowSpanData.count - 1;\n            if (spannedIndex > endIndex) {\n                endIndexList.push(spannedIndex);\n            }\n        }\n    },\n\n    /**\n     * row end index 기준으로 rowspan 을 확인하며 endRangeList 를 업데이트 하는 함수\n     * @param {object} param - parameters\n     * @private\n     */\n    _concatRowSpanIndexFromEnd: function(param) {\n        var endIndex = param.endIndex;\n        var columnName = param.columnName;\n        var rowSpanData = param.endRowSpanDataMap &amp;&amp; param.endRowSpanDataMap[columnName];\n        var endIndexList = param.endIndexList;\n        var dataModel = param.dataModel;\n        var spannedIndex, tmpRowSpanData;\n\n        if (!rowSpanData) {\n            return;\n        }\n\n        if (!rowSpanData.isMainRow) {\n            spannedIndex = endIndex + rowSpanData.count;\n            tmpRowSpanData = dataModel.at(spannedIndex).getRowSpanData(columnName);\n            spannedIndex += tmpRowSpanData.count - 1;\n            if (spannedIndex > endIndex) {\n                endIndexList.push(spannedIndex);\n            }\n        } else {\n            spannedIndex = endIndex + rowSpanData.count - 1;\n            endIndexList.push(spannedIndex);\n        }\n    },\n\n    /**\n     * rowSpan 된 Index range 를 반환한다.\n     * @param {{row: Array, column: Array}} spannedRange 인덱스 정보\n     * @returns {{row: Array, column: Array}} New Range\n     * @private\n     */\n    _getRowSpannedIndex: function(spannedRange) {\n        var columnModelList = this.columnModel.getVisibleColumnModelList()\n            .slice(spannedRange.column[0], spannedRange.column[1] + 1);\n        var dataModel = this.dataModel;\n        var startIndexList = [spannedRange.row[0]];\n        var endIndexList = [spannedRange.row[1]];\n        var startRow = dataModel.at(spannedRange.row[0]);\n        var endRow = dataModel.at(spannedRange.row[1]);\n        var newSpannedRange = $.extend({}, spannedRange);\n        var startRowSpanDataMap, endRowSpanDataMap, columnName, param;\n\n        if (!startRow || !endRow) {\n            return newSpannedRange;\n        }\n\n        startRowSpanDataMap = dataModel.at(spannedRange.row[0]).getRowSpanData();\n        endRowSpanDataMap = dataModel.at(spannedRange.row[1]).getRowSpanData();\n\n        //모든 열을 순회하며 각 열마다 설정된 rowSpan 정보에 따라 인덱스를 업데이트 한다.\n        _.each(columnModelList, function(columnModel) {\n            columnName = columnModel.columnName;\n            param = {\n                columnName: columnName,\n                startIndex: spannedRange.row[0],\n                endIndex: spannedRange.row[1],\n                endRowSpanDataMap: endRowSpanDataMap,\n                startRowSpanDataMap: startRowSpanDataMap,\n                startIndexList: startIndexList,\n                endIndexList: endIndexList,\n                dataModel: dataModel\n            };\n            this._concatRowSpanIndexFromStart(param);\n            this._concatRowSpanIndexFromEnd(param);\n        }, this);\n\n        newSpannedRange.row = [Math.min.apply(null, startIndexList), Math.max.apply(null, endIndexList)];\n        return newSpannedRange;\n    }\n});\n\nmodule.exports = Selection;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"